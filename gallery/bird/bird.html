<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Box2DJS - Physics Engine for JavaScript</title>

<script>
/* Based on Alex Arnell's inheritance implementation. */
var Class = {
  create: function() {
    var parent = null, properties = $A(arguments);
    if (Object.isFunction(properties[0]))
      parent = properties.shift();

    function klass() {
      this.initialize.apply(this, arguments);
    }

    Object.extend(klass, Class.Methods);
    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      var subclass = function() { };
      subclass.prototype = parent.prototype;
      klass.prototype = new subclass;
      parent.subclasses.push(klass);
    }

    for (var i = 0; i < properties.length; i++)
      klass.addMethods(properties[i]);

    if (!klass.prototype.initialize)
      klass.prototype.initialize = this.emptyFunction;

    klass.prototype.constructor = klass;

    return klass;
  },
  emptyFunction:function () {}

};

Class.Methods = {
  addMethods: function(source) {
    var ancestor   = this.superclass && this.superclass.prototype;
    var properties = Object.keys(source);

    if (!Object.keys({ toString: true }).length)
      properties.push("toString", "valueOf");

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && Object.isFunction(value) &&
          value.argumentNames().first() == "$super") {
        var method = value, value = Object.extend((function(m) {
          return function() { return ancestor[m].apply(this, arguments) };
        })(property).wrap(method), {
          valueOf:  function() { return method },
          toString: function() { return method.toString() }
        });
      }
      this.prototype[property] = value;
    }

    return this;
  }
};

Object.extend = function(destination, source) {
  for (var property in source)
    destination[property] = source[property];
  return destination;
};

Object.extend(Object, {
  inspect: function(object) {
    try {
      if (Object.isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : String(object);
    } catch (e) {
      if (e instanceof RangeError) return '...';
      throw e;
    }
  },

  toJSON: function(object) {
    var type = typeof object;
    switch (type) {
      case 'undefined':
      case 'function':
      case 'unknown': return;
      case 'boolean': return object.toString();
    }

    if (object === null) return 'null';
    if (object.toJSON) return object.toJSON();
    if (Object.isElement(object)) return;

    var results = [];
    for (var property in object) {
      var value = Object.toJSON(object[property]);
      if (!Object.isUndefined(value))
        results.push(property.toJSON() + ': ' + value);
    }

    return '{' + results.join(', ') + '}';
  },

  toQueryString: function(object) {
    return $H(object).toQueryString();
  },

  toHTML: function(object) {
    return object && object.toHTML ? object.toHTML() : String.interpret(object);
  },

  keys: function(object) {
    var keys = [];
    for (var property in object)
      keys.push(property);
    return keys;
  },

  values: function(object) {
    var values = [];
    for (var property in object)
      values.push(object[property]);
    return values;
  },

  clone: function(object) {
    return Object.extend({ }, object);
  },

  isElement: function(object) {
    return object && object.nodeType == 1;
  },

  isArray: function(object) {
    return object != null && typeof object == "object" &&
      'splice' in object && 'join' in object;
  },

  isHash: function(object) {
    return object instanceof Hash;
  },

  isFunction: function(object) {
    return typeof object == "function";
  },

  isString: function(object) {
    return typeof object == "string";
  },

  isNumber: function(object) {
    return typeof object == "number";
  },

  isUndefined: function(object) {
    return typeof object == "undefined";
  }
});

function $A(iterable) {
  if (!iterable) return [];
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length || 0, results = new Array(length);
  while (length--) results[length] = iterable[length];
  return results;
}

if (WebKit = navigator.userAgent.indexOf('AppleWebKit/') > -1) {
  $A = function(iterable) {
    if (!iterable) return [];
    if (!(Object.isFunction(iterable) && iterable == '[object NodeList]') &&
        iterable.toArray) return iterable.toArray();
    var length = iterable.length || 0, results = new Array(length);
    while (length--) results[length] = iterable[length];
    return results;
  };
}


</script>
    <script src="box2d/box2d.js"></script>
  </head>
<body onload="init();">
<canvas id="canvas" width='500' height='300'></canvas>
<script>
var World,Body1,Body2;
var canvas, context;


//初始化
function init(){
	
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");
	canvasWidth = parseInt(canvas.width);
    canvasHeight = parseInt(canvas.height);
    canvasTop = parseInt(canvas.offsetTop);
    canvasLeft = parseInt(canvas.offsetLeft);
	
	box2dMain();
}

//初始化box2d
function box2dMain() {
	
    setupWorld();				//1. 创建一个世界
    addBodys();					//2. 为世界创建物体
    setInterval(step, 1000/60);	//3. 让世界动起来

}

//setupWorld()
function setupWorld(){

    //1. 设置有效区域大小 - b2AABB 类 （左上角向量,右下角向量）
    worldAABB = new b2AABB();
    worldAABB.minVertex.Set(-1000, -1000);	//左上角
    worldAABB.maxVertex.Set(1000, 1000); 	//右下角

    //2. 定义重力 - 2D向量 - b2Vec2 类 （x,y）
    gravity = new b2Vec2(0, 300);

    //3. 忽略休眠的物体
    var doSleep = true;

    //4. 创建世界 - b2World
    World = new b2World(worldAABB, gravity, doSleep);
}


//addBodys()
function addBodys(){

    //1. 定义形状	b2CircleDef,b2BoxDef,b2PolyDef 类
	var Shape1 = new b2CircleDef();	//Shape1:圆形
	Shape1.radius = 20;					//半径
	Shape1.localPosition.Set(0, 0);		//偏移量
    Shape1.density = 1.0;				//密度
    Shape1.restitution = .3;			//弹性
    Shape1.friction = 1;				//摩擦力
        
	var Shape2 = new b2PolyDef();	//Shape2:多边形
	Shape2.vertexCount = 3;						//顶点数为5
	Shape2.vertices[0] = new b2Vec2(0,-20);		//顶点1
	Shape2.vertices[1] = new b2Vec2(23.10,20);	//顶点2
	Shape2.vertices[2] = new b2Vec2(-23.10,20);	//顶点3
	Shape2.localPosition.Set(0, 30);	//偏移量
    Shape2.density = 1.0;				//密度
    Shape2.restitution = .3;			//弹性
    Shape2.friction = 1;				//摩擦力

	//2. 定义物体	b2BodyDef 类
    var BodyDef1 = new b2BodyDef();
    BodyDef1.position.Set(100, 100);	//设置物体的初始位置
    BodyDef1.AddShape(Shape1);			//物体中加入Shape1
    BodyDef1.AddShape(Shape2);			//物体中加入Shape2

	//3. 将物体添加至world
    Body = World.CreateBody(BodyDef1);	//在世界中创建物体


	//...可用同样流程继续添加物体，再定义一块地板
	var Shape3 = new b2BoxDef();	//Shape3:矩形
	
    Shape3.extents.Set(200, 5);			//定义矩形高、宽
    Shape2.density = 0;					//墙体密度为0
    Shape2.restitution = .3;			//弹性
    Shape2.friction = 1;				//摩擦力
	var BodyDef2 = new b2BodyDef();
    BodyDef2.position.Set(220, 500);	//设置物体的初始位置
    BodyDef2.AddShape(Shape3);			//物体中加入Shape3
    Body2 = World.CreateBody(BodyDef2);	//在世界中创建物体
}


//计算和绘制世界的下一帧
function step(){

	var dt = 1/60;
	//迭代次数，影响物体碰撞的计算精度，太高会导致速度过慢
	var iterations = 10;

	//计算dt秒之后世界中物体的位置
	World.Step(dt,iterations);

	//绘制世界
	drawWorld();

}


//绘制世界
function drawWorld(){
	//绘制之前将上一帧的内容清除
	context.clearRect(0, 0, canvasWidth, canvasHeight);
	//遍历世界中的物体
    for (var b = World.m_bodyList; b; b = b.m_next) {
		//遍历物体中的形状
        for (var s = b.GetShapeList(); s != null; s = s.GetNext()) {
            this.drawShape(s);	//绘制一个形状
        }
    }
}

//绘制一个形状
function drawShape(shape){
    context.strokeStyle = '#000';		//线形
    context.beginPath();
    switch (shape.m_type) {
        case b2Shape.e_circleShape:{	//如果是圆形，画圆
            var circle = shape;
            var r = circle.m_radius;
            var pos = circle.m_position;
            var pos2 = circle.m_R.col1.clone().scale(r).add(pos);
            context.arc(pos.x, pos.y, r, 0, Math.PI * 2, false);
            context.moveTo(pos.x, pos.y);
            context.lineTo(pos2.x, pos2.y);
            break;
        }
        case b2Shape.e_polyShape:{		//如果是多边形，画多边形
            var poly = shape;
            var tV = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[0]));
            context.moveTo(tV.x, tV.y);
            for (var i = 0; i < poly.m_vertexCount; i++) {
                var v = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[i]));
                context.lineTo(v.x, v.y);
            }
            context.lineTo(tV.x, tV.y);
            break;
        }
    }
    context.stroke();	//绘制
}

</script>
</body>
</html>
