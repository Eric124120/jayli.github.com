<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="http://a.tbcdn.cn/app/dp/s/screen.css" />
<style>
#bd {margin-left:20px;margin-right:20px;}
</style>
<title>wd-gallery - markdown</title>
</head>
<body>
<div id="bd">

<p><style>
p img {
    float:none;
}
</style></p>

<h1>第10章 部署</h1>

<p>事实上，合理地部署你的Web应用程序和开发它时一样地重要；如果加载速度太慢，就算你是在建设未来的Facebook，对于那些实际使用的人来说也毫无意义。用户希望你的站点在提供服务的时候能尽量的可靠和快速。部署JavaScript和HTML文件听起来很简单——毕竟它们只是资源文件——但它们的数量相当的大。在构建Web应用程序时，这是一个常常被忽视的部分。</p>

<p>幸运的是，已经有一些试验和测试过的技术应该适合于所有JavaScript应用程序，事实上它们也适合任何类型的静态资源文件。如果遵守如下的建议，你将找到自己的方法来提供快速的Web应用程序。</p>

<h2>性能</h2>

<p>提高性能，最简单的也是最显著的方法就是：最小化HTTP请求的数量。每一个HTTP请求除了有TCP开销以外还包含了大量的头信息。保持最小的独立连接数可以保证用户的页面加载速度更快。这显然涉及到了服务器需要传输的数据量问题。让页面和其资源文件保持较小的体积将减少网络用时——对任何互联网上的应用而言这才是真正的瓶颈。</p>

<p>将多个脚本文件连接成一个脚本，将多个CSS合并成一个样式表将减少页面渲染所需的HTTP连接的数量。可以在部署或运行时做这样做。如果是后者，务必保证生成的文件在生产环境中可以被缓存。</p>

<p>使用CSS Sprites技术合并多张小图为一张大图，然后使用CSS的background-image和background-position属性在页面中显示对应的图片。只需要将范围覆盖希望显示的图片的背景位置坐标。</p>

<p>避免重定向也是最小化HTTP请求的数量的方法。你也许认为这很少见，当一个URL结尾缺少斜线（/）是一个最常见的重定向场景，而这个斜线本应存在。例如，当前访问http://facebook.com会重定向到http://facebook.com/。如果使用了Apache，可以使用<code>Alias</code>或<code>mod_rewrite</code>修正这个问题。</p>

<p>理解浏览器如何下载资源也很重要。为了加速页面渲染，现代浏览器并行下载所需的资源。但是，直到所有的样式表和脚本下载完成之前页面是不会开始渲染的。有些浏览器更是变本加厉，在处理任何JavaScript文件时，阻塞其他资源的下载。</p>

<p>尽管如此，大多数脚本需要访问DOM并且增加一些诸如事件句柄之类的东西，它们会在页面加载完成后执行。换言之，浏览器没有必要在一切都下载完成之前限制页面的渲染，这样做降低了性能。通过设置脚本的defer属性来解决这个问题，这告诉浏览器该脚本不会在页面加载完成之前操作DOM：</p>

<pre><code>&lt;script src="foo.js" type="text/javascript" charset="utf-8" defer&gt;&lt;/script&gt;
</code></pre>

<p>设置defer属性为“defer”的脚本将和其他资源一起并行下载，它们不会阻塞页面的渲染。HTML5还引入了一个新的脚本下载和执行的模式称作async。通过设置async属性，脚本将在完成下载后一旦有机会才会执行代码。这意味着有可能（很有可能）异步不会按照它们在页面中出现的顺序执行代码，离开了依赖错误的机会。如果脚本没有依赖关系，async则是很有用的。例如Google Analytics默认利用了该特性：</p>

<pre><code>&lt;script src="http://www.google-analytics.com/ga.js" async&gt;&lt;/script&gt;
</code></pre>

<h2>缓存</h2>

<p>如果没有缓存，互联网早就在网络流量拥堵下崩溃了。缓存就是存储最近请求的资源到本地，以便接下来的请求能从磁盘中使用它们而不用再次去下载了。明确地告诉浏览器什么可以被缓存的是很重要的。有些浏览器如Chrome会使用它们自己默认的决策，但切不可由此依靠它。</p>

<p>针对静态资源，通过添加一个很远的将来的Expires头让缓存“永不”失效。这将保证浏览器只会下载该资源一次。所有的静态资源文件都应该这样设置，包括脚本、样式表和图片。</p>

<pre><code>Expires: Thu, 20 March 2015 00:00:00 GMT
</code></pre>

<p>应该相对于当前日期设置一个很远的将来的失效日期。如上例告诉浏览器该缓存在2015年3月20日之前不会过期。如果使用了Apache，使用ExpiresDefault可以方便地设置一个相对的失效日期：</p>

<pre><code>ExpiresDefault "access plus 5 years"
</code></pre>

<p>但是如果想在那个时间之前让资源过期怎么办呢？一种很有用的技术就是在引用资源文件的URL查询参数中添加文件的修改时间（或mtime）。例如Rails默认采用这种方式。然后，任何时候文件被修改，资源文件的URL就会改变，也即清除了缓存。</p>

<pre><code>&lt;link rel="stylesheet" href="master.css?1296085785" type="text/css"&gt;
</code></pre>

<p>HTTP 1.1引入了一类新的头，Cache-Control。它带给开发者更高级的缓存，同时还弥补了Expires的不足。Cache-Control的控制头信息有很多选项，可用逗号隔开：</p>

<pre><code>Cache-Control: max-age=3600, must-revalidate
</code></pre>

<p>查看全部的选项，请访问规范（http://www.ietf.org/rfc/rfc2616.txt）。其中很可能经常会用到的那些列举如下：</p>

<p>max-age</p>

<p>以秒为单位，指定资源为最新的最大有效时间。和Expires不一样的是该指令是相对于该请求的时间。</p>

<p>public</p>

<p>标记资源是可被缓存的。默认情况下，通过SSL或使用HTTP认证后访问的资源，缓存是关闭的。</p>

<p>no-store</p>

<p>完全关闭缓存，只对动态内容你可能希望使用此特性。</p>

<p>must-revalidate</p>

<p>告诉缓存它们必须遵循任何你给定的信息考虑资源的新旧度。在某些条件下，HTTP允许缓存针对它们自己的规则使用过期的资源。通过指定该选项，告诉缓存要严格按照你的规则决策。</p>

<p>给提供服务的资源增加Last-Modified头信息也有助于缓存。浏览器在对该资源后续的请求中，就能指定If-Modified-Since头信息，一个时间戳。如果该资源在最后一次访问之后未被修改，服务器只返回304状态码（未修改）。浏览器仍然可以请求，但服务器却不一定在响应中返回该资源的内容，以此来节省网络时间和带宽：</p>

<pre><code># Request
GET /example.gif HTTP/1.1
Host:www.example.com
If-Modified-Since:Thu, 29 Apr 2010 12:09:05 GMT

# Response
HTTP/1.1 200 OK
Date: Thu, 20 March 2009 00:00:00 GMT
Server: Apache/1.3.3 (Unix)
Cache-Control: max-age=3600, must-revalidate
Expires: Fri, 30 Oct 1998 14:19:41 GMT
Last-Modified: Mon, 17 March 2009 00:00:00 GMT
Content-Length: 1040
Content-Type: text/html
</code></pre>

<p>Last-Modified的替代方式是：ETag。Etag就像比较两个文件的哈希值；如果ETag值不一致，缓存就过期了，必须重新验证。它的工作原理和Last-Modified头信息一样。服务器将用ETag头信息附件该值到资源响应中，客户端将用If-None-Match头信息检查：</p>

<pre><code># Request
GET /example.gif HTTP/1.1
Host:www.example.com
If-Modified-Since:Thu, 29 Apr 2010 12:09:05 GMT
If-None-Match:"48ef9-14a1-4855efe32ba40"

# Response
HTTP/1.1 304 Not Modified
</code></pre>

<p>ETag通常是使用服务器指定的一些属性来构建的——也就是说，两个独立的服务器对同样的资源生成的ETag可能不一样。随着服务器集群越来越普遍，这是一个现实的问题。个人而言，我建议坚持使用Last-Modfied并且关闭ETag。</p>

<h2>源码压缩（Minification）</h2>

<p>JavaScript源码压缩是从脚本文件中删除不必要的字符，它不改变功能。删除的字符包括空白、换行和注释。更好的压缩工具应该能够翻译JavaScript。因此，它们能安全地缩短变量和函数的名字，这样就进一步减少了字符。文件越小越好，因此在网络上传输的数据就更少了。</p>

<p>不仅仅可以对JavaScript文件进行压缩，样式表和HTML文件也可以被压缩。特别是样式表通常包含了大量冗余的空白。压缩最好能在部署时就完成，因为开发时你不希望调试任何压缩过的代码。如果在生产环境中有一个错误，首先应该尝试在开发环境中复现——你会发现这样更容易调试错误。</p>

<p>源码压缩带来额外的好处是让代码晦涩难读。总是存在有充分动机的人能将代码重建出来，但对非正常的观察者来说这是一个障碍。</p>

<p>当前有很多源码压缩的工具，但我建议选择一个带有JavaScript引擎能够翻译代码的工具。YUI Compressor（http://developer.yahoo.com/yui/compressor）是我的最爱，因为它有很好的维护和支持。它是由Yahoo!工程师Julien Lecomte开发的，它的目标就是通过智能优化源代码，要比JSMin（http://www.crockford.com/javascript/jsmin.html）更好地缩减JavaScript文件大小【译注1】。假设有如下函数：</p>

<p>【译注1：对于带有中文的JavaScript文件来说，仅做源码压缩是不够的，还需要对文件做Unicode转码，以保证压缩后的文件不会因为编码问题引入bug，此外，由于每个项目中的JS文件往往比较多，也需要一些批量压缩工具来提高工作效率，这里推荐一个工具TPacker：http://github.com/taobao-wd/Tpacker】</p>

<pre><code>function per(value, total) {
    return( (value / total) * 100 );
}
</code></pre>

<p>除了移除空白，YUI Compressor会缩短局部变量来节省更多的字符：</p>

<pre><code>function per(b,a){return((b/a)*100)};
</code></pre>

<p>YUI Compressor实际上解析了JavaScript代码，它通常会替换变量——不会引入代码错误。但也不总是如此；偶尔它也不能揣摩你的代码，只能保持原样。最最常见的原因是代码中使用了eval()或with()语句。如果它检测到你使用了任何一种，它就不再应用变量替换了。另外，eval()和with()都会导致性能问题——浏览器的JIT编译器有和压缩器一样的问题。我个人的建议是不要使用任何这类语句。</p>

<p>使用YUI Compressor最简单的方法就是下载其二进制文件（http://yuilibrary.com/downloads/#yuicompressor），它依赖Java，在命令行中执行：</p>

<pre><code>java -jar yuicompressor-x.y.z.jar foo.js | foo.min.js
</code></pre>

<p>尽管如此，也可以在部署时通过编程来实现。如果使用了类似Sprockets（http://getsprockets.org）或Less（http://lesscss.org）这样的库，它们便可以做到这类功能。否则，YUI Compressor也提供了一些库的接口，例如Sam Stephenson的Ruby-YUI-Compressor gem（https://github.com/sstephenson/ruby-yui-compressor）或Jammit库（http://documentcloud.github.com/jammit）。</p>

<h2>Gzip压缩</h2>

<p>在Web上Gzip是最流行并且支持最好的压缩方式。它是由GNU项目开发的，在HTTP/1.1中增加支持的。Web客户端发送请求是增加Accept-Encoding头信心来标识自己支持的压缩方式：</p>

<pre><code>Accept-Encoding: gzip, deflate
</code></pre>

<p>如果Web服务器看到该头信息，并且支持列出的压缩方式，它将会压缩发送的响应，并通过Content-Encoding头信息标识其压缩方式：</p>

<pre><code>Content-Encoding: gzip
</code></pre>

<p>然后浏览器才能正确地解码得到的响应。显然，压缩数据可以减少网络时间，但它并没大范围地得以实现。Gzip通常能减少响应70%的体积，这巨大的缩减极大地加速了网站的加载速度。</p>

<p>服务器通常已经配置了哪些文件类型应该被压缩。一条尚好的经验就是压缩任何文本响应，例如HTML、JSON、JavaScript和样式表。如果文件已经被压缩，例如图片和PDF，则不应该再用Gzip压缩了，因为体积不会在减小了。</p>

<p>依赖于使用的服务器来配置Gzip，但在Apache 2.x或更高的版本中，你需要<code>mod_deflate</code>模块<code>（http://httpd.apache.org/docs/2.0/mod/mod_deflate.html）</code>。对于其他的服务器，请查看各自的文档。</p>

<h2>使用CDN</h2>

<p>内容分发网络或叫CDN，为你的站点提供静态资源内容服务，以减少它们的加载时间。用户和Web服务器之间的距离对加载时间有直接的影响。CDN将你的内容部署在跨越多个地理位置的服务器上，故当用户请求一个响应时，可从就近的服务器得到服务（理想情况是在同一个国家中）。Yahoo!已经发现CDN可以改善终端用户20%或更多的响应时间（http://developer.yahoo.com/performance/rules.html#cdn）。</p>

<p>根据你能承担的费用，当前有很多提供CDN服务的公司，如Akamai Technologies（http://www.akamai.com），Limelight Networks（http://www.limelightnetworks.com），EdgeCast（http://www.edgecast.com）和Level 3 Communications（http://www.level3.com）。Amazon Web Services（http://aws.amazon.com）最近发布了一个能够支付得起叫做Cloud Front（http://aws.amazon.com/cloudfront），它和S3服务（http://aws.amazon.com/s3）紧密地捆绑在一起，对初创的公司也许是个不粗的选择。</p>

<p>Google为很多流行的开源JavaScript库提供了一个免费的CDN和加载架构，包括jQuery和jQueryUI。使用Google的CDN的其中一个优点就是很多其他网站都在使用它，这增加了你要引用的JavaScript文件已经在用户浏览器中的可能性。</p>

<p>首先，检出可用的库的列表（http://code.google.com/apis/libraries/devguide.html）。假如说想要包含jQuery库（http://code.google.com/apis/libraries/devguide.html#jquery），既可以使用Google的JavaScript加载器或者更简单地使用script标签：</p>

<pre><code>&lt;!-- minimized version of the jQuery library --&gt;
&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"&gt;&lt;/script&gt;
&lt;!-- minimized version of the jQuery UI library --&gt;
&lt;script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.8.6/jquery-ui.min.js"&gt;
&lt;/script&gt;
</code></pre>

<p>你会发现在上面的例子中我们没有指定请求的协议，而只使用//。这个鲜为人知的技巧使得获取脚本文件时使用和宿主页面一样的协议。换言之，如果页面通过安全的HTTPS加载，该脚本文件同样会使用HTTPS，从而避免所有的安全警告。没有协议的相对URL是合法并的，与RTF规范兼容的。更重要的是，它得到了全盘的支持；见鬼了！协议-相对URL甚至在IE 3.0中也能工作。</p>

<h2>审查工具</h2>

<p>有一些工具非常好，考虑你的网站性能时它们能给你眼前一亮的惊喜。YSlow（http://developer.yahoo.com/yslow）是Firebug的扩展，而Firebug是Firefox的扩展。你需要安装所有这3个才能使用。一旦安装，就可以用它来审查Web页面了。扩展通过一系列的检查来运行，包括缓存、源码压缩、Gzip压缩和CDN等。它将为网站给出评分等级，这依赖于检查过程中的耗费。然后，给出如何改进分数的建议。</p>

<p>Google Chrome和Safari也有审查工具，但是这些是内置在浏览器中的。如图10-1所展现的，在Chrome中只要简单地到Web Inspector的Audits面板中点击Run就行了。能看到这些真的很棒：你的网站有哪些是可以改进的，从而来提高它的性能。如图10-1。</p>

<p><img src="http://img01.taobaocdn.com/tps/i1/T1_TGBXkhmXXXXXXXX-803-226.png" alt="" /></p>

<p>图10-1. 使用Web Inspector来监控网页性能</p>

<h2>资源</h2>

<p>Yahoo!和Google都花了大量的研究调查来分析Web性能。很明显，提高网站的渲染速度是他们最感兴趣的，对他们自己的服务和客户浏览无联网时的用户体验都有好处。事实上，Google现在考虑其Pagerank算法的速度，它帮助在搜索查询时决定网站的等级在哪里。两个公司在改善性能上都有优秀的资源，可以在Google（http://code.google.com/speed/page-speed/docs/payload.html）和Yahoo!（http://code.google.com/speed/page-speed/docs/payload.html）的开发者网站上找到这些资源。</p>
</div>
</body>
</html>
