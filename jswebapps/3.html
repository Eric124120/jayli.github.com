<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="http://a.tbcdn.cn/app/dp/s/screen.css" />
<style>
#bd {margin-left:20px;margin-right:20px;}
</style>
<title>wd-gallery - markdown</title>
</head>
<body>
<div id="bd">

<h1>第3章 模型和数据</h1>

<p>将应用重心从后台迁往前台的一个挑战是数据管理。传统方式是通过页面请求从数据库获取数据，用户和页面中的结果进行直接交互。然而在复杂的JavaScript应用中做数据管理是非常困难的。前端并没有请求/响应模型，也没办法访问服务器端的数据，甚者，从远程取回的数据只是临时的保存在客户端。</p>

<p>尽管这种（从后台迁往前台的）转变依然在激烈争论之中，但这还是有一些好处的。比如，客户端数据存储速度非常块，几乎是瞬间读取的，因为数据是直接从内存中获得的。这会让你的应用接口变得与众不同，所有交互操作都会瞬间得到响应，这极大提高了产品的用户体验。</p>

<p>如何在客户端架构数据存储呢？这需要很多思考。这就象要走出一个充满诱惑和陷阱的迷宫，对于程序员新手来说困难重重，尤其是对于那些想要把自己的应用做大的开发者来说更是如此。本章我们会介绍如何最好的达成这种转变，我也会给出一些推荐的模式和最佳实践。</p>

<h2>MVC和命名空间</h2>

<p>要确保应用中的视图、状态和数据彼此清晰的分离，这样才能让架构更加整洁有序且更加健壮。引入MVC模式，数据管理则归入模型（MVC中的M）。模型应当从视图和控制器中解偶出来。与数据操作和行为相关的逻辑都应当放入模型中，通过命名空间进行管理。</p>

<p>在JavaScript中，我们通过给对象添加属性来管理一个命名空间，这个命名空间可以是函数，也可以是变量，比如：</p>

<pre><code>var User = {
   records: [ /* ... */ ]
};
</code></pre>

<p>User的数组数据就在命名空间User.records中。和user相关的函数也可以放入User模型里，比如，我们使用fetchRemote()函数来从服务端获取user的数据：</p>

<pre><code>var User = {
   records: [],
   fetchRemote: function(){ /* ... */ }
};
</code></pre>

<p>将模型的属性保存至命名空间中的做法可以确保不会产生冲突，这也是符合MVC原则的。同时也能避免你的代码变成一堆函数和回调混杂在一起的大杂烩。</p>

<p>我们可以将命名空间做一点改进，将那些和user实例相关的函数也都添加进去。假设user包含一个destory()函数，它是和具体的user实例相关的，因此这个函数应当基于User的实例进行调用。</p>

<pre><code>var user = new User;
user.destroy()
</code></pre>

<p>为了做到这一点，我们应当将User写成一个类，而不是一个对象：</p>

<pre><code>var User = function(atts){
   this.attributes = atts || {};
};

User.prototype.destroy = function(){
   /* ... */
};
</code></pre>

<p>对于那些和具体的user实例不相关的函数和变量，则可以直接定义在User对象中：</p>

<pre><code>User.fetchRemote = function(){
   /* ... */
};
</code></pre>

<p>关于命名空间的更多内容，请参阅Peter Michaux的博客，其中有一个关于命名空间专题的文章（http://goo.gl/FOnPL），非常不错。</p>

<h2>构建对象关系映射（ORM）</h2>

<p>对象关系映射（Ojbect-relational mapper，简称ORM）是在除JavaScript以外的编程语言中常见的一种数据结构。然而在JavaScript应用中，对象关系映射也是一种非常有用的技术，它可以用来做数据管理以及用作模型。比如使用ORM你可以将模型和远程服务捆绑在一起，任何模型实例的改变都会在后台发起一个Ajax请求到服务器端。或者你可以将模型实例和HTML元素绑定在一起，任何对实例的更改都会在界面中反映出来。这些例子会在之后详细讨论，现在让我们来创建一个自定义ORM。</p>

<p>本质上讲，ORM是一个包装了一些数据的对象层。以往ORM常用于抽象SQL数据库，但在这里ORM只是用于抽象JavaScript数据类型。这个额外的层有一个好处，我们可以通过给它添加自定义的函数和属性来增强基础数据的功能。比如添加数据的合法性验证、监听、数据持久化以及服务端的回调处理等等，这样会增加代码的重用率。</p>

<h3>原型继承</h3>

<p>这里使用Object.create()来构造我们的ORM，这和在第1章中提到的基于类的例子有一点不同。这里使用基于原型（prototype-based）的继承，而没有用到构造函数和new关键字。</p>

<p>Object.create()只有一个参数即原型对象，它返回一个新对象，这个新对象的原型就是传入的参数。换句话说，传入一个对象，返回一个继承了这个对象的新对象。</p>

<p>Object.create()最近才添加进了ECMAScript 第5版规范，因此在有些浏览器中并未实现，比如IE。但这并不是什么大问题，如果需要的话，我们可以很容易的模拟出这个函数：</p>

<pre><code>if (typeof Object.create !== "function")
   Object.create = function(o) {
       function F() {}
       F.prototype = o;
       return new F();
   };
</code></pre>

<p>这段示例代码摘自Douglas Crockford的文章“原型继承”（http://goo.gl/OLQhp）。如果想深入挖掘JavaScript原型和继承的机制可以参阅这篇文章。</p>

<p>现在来创建Model对象，Model将用于创建新模型和实例：</p>

<pre><code>var Model = {
   inherited: function(){},
   created: function(){},

   prototype: {
       init: function(){}
   },

   create: function(){
       var object = Object.create(this);
       object.parent = this;
       object.prototype = object.fn = Object.create(this.prototype);

       object.created();
       this.inherited(object);
       return object;
   },

   init: function(){
       var instance = Object.create(this.prototype);
       instance.parent = this;
       instance.init.apply(instance, arguments);
       return instance;
   }
};
</code></pre>

<p>如果你不熟悉Object.create()，这段代码读起来会很晦涩，所以我把它分解来讲。create()函数返回一个新对象，这个对象继承自Model对象；我们使用它来创建新模型。init()函数返回一个新对象，它继承自Model.prototype，这个新对象是Model对象的一个实例：</p>

<pre><code>var Asset = Model.create();
var User = Model.create();

var user = User.init();
</code></pre>

<h3>添加ORM属性</h3>

<p>现在如果给Model添加属性，对于继承的模型来说，这些新增属性都是可访问的：</p>

<pre><code>// 添加对象属性
jQuery.extend(Model, {
   find: function(){}
});

// 添加实例属性
jQuery.extend(Model.prototype, {
   init: function(atts) {
       if (atts) this.load(atts);
   },

   load: function(attributes){
       for(var name in attributes)
       this[name] = attributes[name];
   }
});
</code></pre>

<p>jQuery.extend()只是代替for循环手动拷贝属性的一种快捷方式，这和我们在load()函数中的做法差不多。现在，我们的对象和实例属性都传播到了单独的模型里：</p>

<pre><code>assertEqual( typeof Asset.find, "function" );
</code></pre>

<p>实际上我们会增加很多属性，因此还需将extend()和include()添加至Model对象中：</p>

<pre><code>var Model = {
   /* ... 代码片段 ... */
   extend: function(o){
       var extended = o.extended;
       jQuery.extend(this, o);
       if (extended) extended(this);
   },
   include: function(o){
       var included = o.included;
       jQuery.extend(this.prototype, o);
       if (included) included(this);
   }
};

// 添加对象属性
Model.extend({
   find: function(){}
});

// 添加实例属性
Model.include({
   init: function(atts) { /* ... */ },
   load: function(attributes){ /* ... */ }
});
</code></pre>

<p>现在我们可以创建asset并设置一些属性：</p>

<pre><code>var asset = Asset.init({name: "foo.png"});
</code></pre>

<h3>持久化记录</h3>

<p>我们需要一种保持记录持久化的方法，即将引用保存至新创建的实例中以便任何时候都能访问它。我们通过在Model中定义records对象来实现。当我们保存一个实例的时候，就将它添加进这个对象中，当删除实例时，则将它从对象中删除：</p>

<pre><code>// 用来保存记录的对象
Model.records = {};
Model.include({
   newRecord: true,
   create: function(){
       this.newRecord = false;
       this.parent.records[this.id] = this;
   },
   destroy: function(){
       delete this.parent.records[this.id];
   }
});
</code></pre>

<p>如何更新一个已存在的实例呢？简单——只需更新对象引用即可：</p>

<pre><code>Model.include({
   update: function(){
       this.parent.records[this.id] = this;
   }
});
</code></pre>

<p>现在创建一个快捷函数来保存实例，这样就不用每次都检查这个实例是否已经保存过或是否需要新创建实例了：</p>

<pre><code>// 将对象存入记录哈希表中，保持一个引用指向它
Model.include({
   save: function(){
       this.newRecord ? this.create() : this.update();
   }
});
</code></pre>

<p>如何实现一个用来根据ID查找资源的find()函数呢？</p>

<pre><code>Model.extend({
   // 通过ID查找，找不到则抛出异常
   find: function(id){
       return this.records[id] || throw("Unknown record");
   }
});
</code></pre>

<p>现在我们已经成功的创建了一个基本的ORM，我们来运行一下：</p>

<pre><code>var asset = Asset.init();
asset.name = "same, same";
asset.id = 1
asset.save();

var asset2 = Asset.init();
asset2.name = "but different";
asset2.id = 2;
asset2.save();

assertEqual( Asset.find(1).name, "same, same" );

asset2.destroy();
</code></pre>

<h2>增加ID支持</h2>

<p>此时，每次我们保存一条记录都必须手动指定一个ID。这实在是糟透了，但幸运的是，我们可以加入自动化处理。首先，我们需要一个方法来自动生成ID，可以使用全局统一标识（Globally Unique Identifier，简称GUID）生成器来做这一步。从技术的角度讲，出于API的原因，JavaScript无法友好正式的生成128位的GUID，它只能生成伪随机数。生成真正随机的GUID是一个众所周知的难题，操作系统使用MAC地址、BIOS的校验和、测量电信号的噪音或者检测放射性衰变来计算GUID，甚至用上了熔岩灯【译注：熔岩灯又称为蜡灯,水母灯。名字源于其内不定形状蜡滴的缓慢流动，让人联想到熔岩的流动。熔岩灯有多种形状和颜色，多用于装饰，更多信息请参照http://zh.wikipedia.org/wiki/熔岩灯】。但JavaScript中内置的Math.random()方法尽管产生的是伪随机数，但也足够用了。</p>

<p>Robert Kieffer写了一个简单明了的GUID生成器，它使用Math.random()来产生一个伪随机的GUID（http://goo.gl/0b0hu），代码也很简单：</p>

<pre><code>Math.guid = function(){
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
       var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8);
       return v.toString(16);
   }).toUpperCase();
};
</code></pre>

<p>现在我们有了生成GUID的方法，可以很容易将它集成入ORM里，剩下的只需修改create()函数了：</p>

<pre><code>Model.extend({
   create: function(){
       if ( !this.id ) this.id = Math.guid();
       this.newRecord = false;
       this.parent.records[this.id] = this;
   }
});
</code></pre>

<p>这样任何新创建的记录都包含一个随机的GUID作为它们的标识：</p>

<pre><code>var asset = Asset.init();
asset.save();

asset.id //=&gt; "54E52592-313E-4F8B-869B-58D61F00DC74"
</code></pre>

<h2>寻址引用</h2>

<p>如果你足够细心的话，就会发现我们的ORM中存在一个引用的bug。当保存或通过find()查找记录时，所返回的实例并没有克隆一份，因此对任何属性的修改都会影响原始数据。这的确是一个问题，因为我们只想当调用update()方法的时候才会修改asset：</p>

<pre><code>var asset = new Asset({name: "foo"});
asset.save();

// 正确的传入一个记录
assertEqual( Asset.find(asset.id).name, "foo" );

// 更改属性，而没有调用update()
asset.name = "wem";

// 天那，出问题了，因为asset的名字被修改为“wem”
assertEqual( Asset.find(asset.id).name, "foo" );
</code></pre>

<p>我们需要修复这个问题，在执行find()操作的时候新创建一个对象。同样在创建或更新记录的时候都需要复制对象：</p>

<pre><code>Asset.extend({
   find: function(id){
       var record = this.records[id];
       if ( !record ) throw("Unknown record");
       return record.dup();
   }
});
Asset.include({
   create: function(){
       this.newRecord = false;
       this.parent.records[this.id] = this.dup();
   },
   update: function(){
       this.parent.records[this.id] = this.dup();
   },
   dup: function(){
       return jQuery.extend(true, {}, this);
   }
});
</code></pre>

<p>这里存在另外一个问题，Model.records是由被所有模型所共享的对象：</p>

<pre><code>assertEqual( Asset.records, Person.records );
</code></pre>

<p>非常不幸，这在合并所有的记录时会有副作用：</p>

<pre><code>var asset = Asset.init();
asset.save();

assert( asset in Person.records );
</code></pre>

<p>解决办法是在创建新的模型时设置一个新的records。Model.create()是创建新对象的回调，因此我们可以设置任意描述这个模型的对象：</p>

<pre><code>Model.extend({
   created: function(){
       this.records = {};
   }
});
</code></pre>

<h2>装载数据</h2>

<p>除非你的web应用完全限制在浏览器中运行，否则应用总是需要从服务器端下载一些数据的。应用启动时装载的往往是数据的子集，更多的数据则是在交互发生时装载的。根据应用的类型和数据量的大小，页面初始化时可能会将所有的数据一次性加载进来。这是理想状况，这样的话用户就不必再等待额外的数据载入了。但对多数应用来说这种做法并不具可行性，因为数据量太大以至于这些数据没办法在浏览器内存里老老实实的呆着。
数据的预加载是一个重要的手段，这能让应用的体验更流畅、速度更快，用户的等待时间也尽可能的压缩成很短。但是，在预加载的数据之中可能存在用不到的数据，你需要提前预知用户可能需要哪种类型的数据（或者需要某种方法来判断应用是否依然在线）。</p>

<p>如果你想展示一个可翻页的列表，为什么不预加载下一页的数据，这样在翻页的时候就会更流畅了？或者更进一步，展示一个长长的列表时，当滚动到列表所在的位置时就自动加载并插入数据（无限滚动模式）？当用户更少的感觉到延迟时，体验就会更好。</p>

<p>当你在取数据的时候，要保证UI没有被阻塞。这时需要展示一些加载指示标志，但要确保用户界面依然是可用的。实际工作中很少遇到需要阻塞UI的场景。</p>

<p>数据可以直接嵌套显示在初始页面中，或者通过Ajax或JSONP的方式使用单独的HTTP请求加载数据。就我个人而言，我推荐使用后两种方式，因为直接在初始页面中嵌套数据会增加页面体积，而并行加载会更快一些。AJAX和JSON同样允许你将HTML页面缓存住，而不是每次渲染都会动态发起请求。</p>

<h3>直接嵌套数据</h3>

<p>我真的不推荐使用这种方式，原因在上一段落中已经给出了。但在某些特定场景下还是很有用的，尤其是当下载的数据量很少的时候。而且这种方式的开发成本很低，很易实现。</p>

<p>你只需要直接将JSON对象渲染到页面中，比如使用Rails和Ruby可以这样来实现：</p>

<pre><code>&lt;script type="text/javascript"&gt;
   var User = {};
   User.records = &lt;%= raw @users.to_json %&gt;;
&lt;/script&gt;
</code></pre>

<p>我们使用ERB标签（<code>&lt;%%&gt;</code>）来输出表示用户数据的JSON，raw方法是防止对JSON进行转义处理。当页面渲染输出时，生成的HTML结果看起来像这样：</p>

<pre><code>&lt;script type="text/javascript"&gt;
   var User = {};
   User.records = [{"first_name": "Alex"}];
&lt;/script&gt;
</code></pre>

<p>JavaScript可以直接处理JSON数据，因为JSON数据格式本质上就是一个JavaScript对象。</p>

<h3>通过Ajax载入数据</h3>

<p>当说到后台请求时，你最先想到的载入远程数据的方法可能就是Ajax了，理由很简单，这是一个被充分证明可行而且支持所有浏览器的一种方法。这不是说Ajax就没有缺点，历史中的Ajax并不标准，因此其API也不统一，而且出于安全性的考虑，浏览器默认禁止Ajax夸域读取数据。</p>

<p>如果你想快速学习Ajax和XMLHttpRequest类，请阅读Mozilla开发者手册“Getting Started”（http://goo.gl/TraAz）。大多数情况下，我们都会使用类库比如jQuery来处理Ajax，因为这些类库抽象出一套不错的Ajax API，而且处理了浏览器的兼容性问题。因此这里我们简单讲解一下jQuery的API，这里不会对XMLHttpRequest类做过多介绍。</p>

<p>jQuery的Ajax API包含一个底层方法，jQuery.ajax()，以及一些高级方法，高级方法是对jQuery.ajax()的抽象，目的是减少编程时要写的代码。jQuery.ajax()接收一个哈希表【译注：哈希表就是键值对的集合，这里就是指一个对象，关于哈希表请参照http://goo.gl/QTE67】作为参数，哈希表中存放的是配置信息，包括请求参数、content-type、回调函数以及其他信息。调用这个函数时，jQuery就会在后台发起一个异步请求。</p>

<ul>
<li>url：请求的url，默认是当前页面的url</li>
<li>success：当请求成功时触发的回调函数，从服务器返回的任何数据都会以参数形式带入回调函数</li>
<li>contentType：设置请求的Content-Type头字段，如果请求包含数据，默认值为application/x-www-form-urlencoded，大多数情况下都是使用这个值</li>
<li>data：data是发送给服务器的数据，如果data不是字符串，jQuery会将其作序列化处理并作URL编码</li>
<li>type：HTTP的发送方式：GET、POST或DELETE，默认为GET</li>
<li>dataType：希望从服务器返回的数据类型。jQuery需要知道这个设置以便知道如何处理返回结果，如果没有指定dataType，jQuery将会根据MIME的类型来猜测响应数据的类型，可选的值包括：

<ul>
<li>text：纯文本，不需要作额外处理</li>
<li>script：jQuery将响应结果看作JavaScript代码并执行它</li>
<li>json：jQuery将响应结果看作JSON，并将其转换为对象</li>
<li>jsonp：处理JSONP请求，后续会讨论到</li>
</ul></li>
</ul>

<p>我们来看个例子，这是一个简单的Ajax请求，获取到服务器的数据后将其alert出来：</p>

<pre><code>jQuery.ajax({
   url: "/ajax/endpoint",
   type: "GET",
   success: function(data) {
       alert(data);
   }
});
</code></pre>

<p>然而这些选项看起来有点臃肿，幸运的是，jQuery提供了很多快捷方式，jQuery.get()的参数就很简单，URL、可选的数据和回调函数：</p>

<pre><code>jQuery.get("/ajax/endpoint", function(data){
   $(".ajaxResult").text(data);
});
</code></pre>

<p>或者，如果想要通过GET方式发送少量的查询参数的话，可以这样：</p>

<pre><code>jQuery.get("/ajax/endpoint", {foo: "bar"}, function(data){
   /* ... */
});
</code></pre>

<p>如果希望服务器端返回的是JSON数据，则需要调用jQuery.getJSON()来代替，它会自动将请求的dataType设置为”json”：</p>

<pre><code>jQuery.getJSON("/json/endpoint", function(json){
   /* ... */
});
</code></pre>

<p>与之类似，jQuery中还实现了jQuery.post()方法，同样可以传入URL、数据和回调函数等参数：</p>

<pre><code>jQuery.post("/users", {first_name: "Alex"}, function(result){
   /* Ajax POST was a success */
});
</code></pre>

<p>如果想使用其他的HTTP方法，比如DELETE、HEAD和OPTIONS，则必须使用底层的jQuery.ajax()方法。</p>

<p>这里仅仅是对jQuery的Ajax API的简单介绍，更多详细信息请参阅完整的文档：http://api.jquery.com/category/ajax/。</p>

<p>Ajax的一个限制是同源策略（same origin policy），它要求所有的请求必须来自同一个域名、子域名，并且地址的端口也应当一致。主要原因是出于安全考虑，因为所有的请求都会附带cookie信息一起发送。也就是说，对于远程服务来讲，请求如果是来自于登录后的用户，若没有同源策略的限制，攻击者就有可能获取你的Gmail里的邮件、得到你的Fackbook状态或者你Twitter中的好友，这是一个非常严重的安全性问题。</p>

<p>但是，尽管出于安全问题的考虑而提出了同源策略，这也对那些的确需要跨域获取合法数据的开发者造成一些不方便。诸如Adobe Flash和Java之类的技术已经着手解决了这个问题，通常是使用跨域策略文件。现在Ajax也在迎头赶上，提出了名为CORS的标准规范（cross-origin resource sharing）（http://goo.gl/fofEc）。</p>

<p>CORS打破同源策略的限制，赋予了前端代码访问可信的远程服务的权限。主流的浏览器都很好的支持这个规范，除非使用IE6，基本上可以很好的使用它。</p>

<p>支持CORS的浏览器：</p>

<ul>
<li>IE >= 8 (需要安装caveat)</li>
<li>Firefox >= 3</li>
<li>Safari: 完全支持</li>
<li>Chrome: 完全支持</li>
<li>Opera: 不支持</li>
</ul>

<p>CORS的使用非常简单，如果想将你的服务器添加为受信任的数据源，只需在HTTP协议的响应头里加几行：</p>

<pre><code>Access-Control-Allow-Origin: example.com
Access-Control-Request-Method: GET,POST
</code></pre>

<p>这两个头字段会对来自example.com的夸域GET和POST请求作验证。多个值之间用逗号分隔，就像上面提到的GET,POST一样。如果要添加多个域名，将域名列在Access-Control-Allow-Origin头字段之中，每两个域名之间用逗号分隔。如果允许来自任意域的访问请求，则需要在源中加入通配符（*）。</p>

<p>对于有些浏览器来说，比如Safari，它会首先发起一个OPTION请求以检查服务器是否允许跨域的请求。另一方面，Firefox则会直接发起跨域请求，但当服务器没有配置CORS头字段时会抛出一个安全异常。要注意一下这种浏览器行为的不同。</p>

<p>你甚至可以使用Access-Control-Request-Headers头字段来认证自定义的请求头：</p>

<pre><code>Access-Control-Request-Headers: Authorization
</code></pre>

<p>这也意味着客户端可以在Ajax请求中添加自定义头，比如使用开放认证（OAuth）【译注：OAuth（开放认证）是允许从桌面和网络应用以简单标准的方法进行安全API认证的开放协议】对请求进行签名：</p>

<pre><code>var req = new XMLHttpRequest();
req.open("POST", "/endpoint", true);
req.setRequestHeader("Authorization", oauth_signature);
</code></pre>

<p>不幸的是，尽管CORS是可以正常工作在IE8及更高版本的IE中的，微软还是选择另辟蹊径，不兼容规范且对W3C工作组制定的标准视而不见（http://goo.gl/sLc2R）。微软使用了一个新的对象XDomainRequest，用来代替 XMLHttpRequest进行跨域通信。它的接口和XMLHttpRequest非常相像，它包含一系列约束和限制（http://goo.gl/b3H2N），比如只支持GET和POST方法，不支持验证和自定义字段，最后最让人费解的是，只支持“Content-Type:text/plain”类型的请求。如果你满足了这些限制条件，就可以在IE中使用正确的Access-Control头字段来实现CORS了。</p>

<h3>JSONP</h3>

<p>JSONP（JSON with padding）（http://goo.gl/cqDT6）很早之前就被标准化了，甚至在CORS之前。这是另一种从远程服务端抓取数据的方式。原理是通过创建一个script标签，所辖的外部文件包含一段JSON数据，数据是由服务器所返回的，作为参数包裹在一个函数调用中。而获取脚本文件并不受跨域的限制，所有浏览器都支持这种技术。</p>

<p>来看这个例子，这里有一个script标签指向一个远程服务：</p>

<pre><code>&lt;script src="http://example.com/data.json"&gt; &lt;/script&gt;
</code></pre>

<p>所请求的文件data.json中包含一个JSON对象，这个对象包裹在一个函数调用中：</p>

<pre><code>jsonCallback({"data": "foo"})
</code></pre>

<p>这时我们定义一个全局函数。当脚本加载后，这个函数就会被执行：</p>

<pre><code>window.jsonCallback = function(result){
   // 处理返回结果相关的逻辑
}
</code></pre>

<p>可以看到这个过程有点小复杂，幸运的是，jQuery将其封装成了简洁的API：</p>

<pre><code>jQuery.getJSON("http://example.com/data.json?callback=?", function(result){
   // 处理返回结果相关的逻辑
});
</code></pre>

<p>jQuery将上面URL中最后的问号替换为一个随机命名的函数。服务器会获取这个callback参数，使用这个名字作为回调函数名称返回给客户端。</p>

<h3>跨域请求的安全性</h3>

<p>如果你的服务器打开了允许来自任何域名的夸域请求或JSONP的支持，你不得不考虑安全问题。跨域策略往往会阻止攻击者调用Twitter的API以及获取你的私人数据。CORS和JSONP则改变了这个情况。通过普通的Ajax请求也会把本地cookies带给服务器，这样就可以利用Twitter的API来模拟登录，任何潜在的攻击者都可以完全控制你的账户。因此何时何地都不要忘记：安全第一。</p>

<p>考虑到这一点，如果你无法控制那些拥有你的API访问权限的域名的话，这时使用CORS/JSONP时有一些要点需要尤为注意：</p>

<ul>
<li>不要暴露任何敏感信息，比如电子邮件地址</li>
<li>禁用任何操作，比如Twitter的“follow”操作</li>
</ul>

<p>或者还有另外一种减少安全隐患的方法，列出可以访问你的数据的域名白名单，或只使用开放认证（OAuth）的身份识别验证。</p>

<h2>向ORM中添加记录</h2>

<p>向ORM中添加数据非常简单。我们只需从服务器抓取数据并更新模型的记录即可。现在给Model对象增加populate()方法，它会对任何给定的值作遍历，创建实例并更新records对象：</p>

<pre><code>Model.extend({
   populate: function(values){
       // 重置model和records
       this.records = {};
       for (var i=0, il = values.length; i &lt; il; i++) {
           var record = this.init(values[i]);
           record.newRecord = false;
           this.records[record.id] = record;
       }
   }
});
</code></pre>

<p>现在我们可以使用Model.populate()函数，传入请求的返回数据：</p>

<pre><code>jQuery.getJSON("/assets", function(result){
   Asset.populate(result);
});
</code></pre>

<p>这样任何从服务器返回的记录都会同步到我们的ORM中了。</p>

<h2>本地存储数据</h2>

<p>在过去本地数据存储一直都是瓶颈。唯一可用的方法就是使用cookies和类似Adobe Flash的插件。Cookies的API非常陈旧，不能存储很大的数据量。并且每次请求都会将cookies带回服务器，增加了不必要的带宽，那么对于Flash来说，这种插件要尽可能的少用。</p>

<p>幸运的是，HTML5加入了对本地存储的支持，而且主流浏览器都已经实现了本地存储。和cookies不同，这些数据妥妥的存放在客户端，且不会发给服务器。而且可存储的数据量非常巨大，不同的浏览器的存储上限也有所不同（甚至不同的版本之间也不同，下面会提到），但至少都能为每个域名提供5MB的存储空间：</p>

<ul>
<li>IE >= 8</li>
<li>Firefox >= 3.5</li>
<li>Safari >= 4</li>
<li>Chrome >= 4</li>
<li>Opera >= 10.6</li>
</ul>

<p>HTML5本地存储的规范源自“HTML5 Web Storage specification”（http://goo.gl/QXxkA），其中包含两类：local storage和session storage。浏览器关闭后local storage数据也能够保持；而session storage数据则在浏览器关闭后就不存在了。浏览器端所存储的数据是以域名分隔开的，某个域中的脚本存储的数据只能被这个域读取。</p>

<p>你可以使用localStorage和sessionStorage对象来访问并操作local storage和session storage。设置属性的操作和JavaScript中的对象操作一样，这两个对象的设置属性操作一模一样：</p>

<pre><code>// 设置一个值 
localStorage["someData"] = "wem";
</code></pre>

<p>WebStorage API还提供了一些新的特性：</p>

<pre><code>// 存储数据的个数
var itemsStored = localStorage.length;

// 设置一个项（是一种键值对的写法）
localStorage.setItem("someData", "wem");

// 得到一个已经存储的项，如果不存在则返回null
localStorage.getItem("someData"); //=&gt; "wem";

// 删除一个项，如果不存在则返回null
localStorage.removeItem("someData");

// 清空本地存储
localStorage.clear();
</code></pre>

<p>数据均存储为字符串，所以如果你想保存的数据是对象或数字，则必须自己作类型转换，如果使用JSON的话，则需要将它先做序列化处理再保存他们，从本地存储中读取JSON时也需要将它转换为对象：</p>

<p>var object = {some: "object"};</p>

<pre><code>// 序列化并保存一个对象
localStorage.setItem("seriData", JSON.stringify(object));

// 读取并将JSON转换为对象
var result = JSON.parse(localStorage.getItem("seriData"));
</code></pre>

<p>如果你存储的数据超出了上限（通常是每个域名5MB），再保存数据时则会抛出QUOTA<em>EXCEEDED</em>ERR异常。</p>

<h2>给ORM添加本地存储</h2>

<p>现在我们来给ORM添加本地存储的支持，这样页面刷新后这些数据也能保存下来。需要首先将记录序列化为JSON字符串，然后使用localStorage对象存储他们。当前的问题是，序列化后的对象看起来是这样：</p>

<pre><code>var json = JSON.stringify(Asset.init({name: "foo"}));
json //=&gt; "{"parent":{"parent":{"prototype":{}},"records":[]},"name":"foo"}"
</code></pre>

<p>所以需要重写我们的模型的序列化JSON的方法。首先需要判断哪些属性需要序列化，我们给Model增加一个attributes数组，它的每个模型都可以用来定位它们的属性：</p>

<pre><code>Model.extend({
   created: function(){
       this.records = {};
       this.attributes = [];
   }
});

Asset.attributes = ["name", "ext"];
</code></pre>

<p>因为每个模型包含不同的属性，因此也不会共享相同的数组引用，attributes属性不会直接设置在Model中，相反，当新创建一个模型时我们创建一个新数组，这和records对象的做法类似。</p>

<p>现在我们来创建attributes()函数，用以返回包含属性到值的映射的对象 ：</p>

<pre><code>Model.include({
   attributes: function(){
       var result = {};
       for(var i in this.parent.attributes) {
           var attr = this.parent.attributes[i];
           result[attr] = this[attr];
       }
       result.id = this.id;
       return result;
   }
});
</code></pre>

<p>现在就可以为每个模型设置一个属性数组了：</p>

<pre><code>Asset.attributes = ["name", "ext"];
</code></pre>

<p>并且这个attributes()函数的返回值是这样：</p>

<pre><code>var asset = Asset.init({name: "document", ext: ".txt"});
asset.attributes(); //=&gt; {name: "document", ext: ".txt"};
</code></pre>

<p>重写JSON.stringify()所需要的也仅仅是模型实例中的toJSON()方法。JSON库使用这个函数来查找需要序列化的对象，而不是这样序列化records对象：</p>

<pre><code>Model.include({
   toJSON: function(){
       return(this.attributes());
   }
});
</code></pre>

<p>让我们再来试一下序列化记录的操作，这次结果中的JSON包含了正确的属性：</p>

<pre><code>var json = JSON.stringify(Asset.records);
json //= "{"7B2A9E8D...":"{"name":"document","ext":".txt","id":"7B2A9E8D..."}"}"
</code></pre>

<p>现在的序列化操作就变得非常优雅，而给模型添加添加本地存储的功能则显得有些琐碎。我们给Model增加两个函数：saveLocal()和loadLocal()。当保存数据的时候，Model.records对象将转换为数组，作序列化，并发送给localStorage：</p>

<pre><code>var Model.LocalStorage = {
   saveLocal: function(name){
       // 将记录转换为数组
       var result = [];
       for (var i in this.records)
           result.push(this.records[i])

       localStorage[name] = JSON.stringify(result);
   },

   loadLocal: function(name){
       var result = JSON.parse(localStorage[name]);
       this.populate(result);
   }
};

Asset.extend(Model.LocalStorage);
</code></pre>

<p>页面加载时从本地存储中读取数据，页面关闭时将数据保存至本地存储中，这的确是个好主意。对于读者来说，应当养成这种处理数据的习惯。</p>

<h2>将新纪录提交给服务器</h2>

<p>在之前的章节中，我们讲到如何使用jQuery的post()方法给服务器发送数据。这个方法有三个参数，URL，请求数据和回调函数：</p>

<pre><code>jQuery.post("/users", {first_name: "Alex"}, function(result){
   /* 当Ajax请求成功时执行*/
});
</code></pre>

<p>现在我们有了attributes()函数，将新记录发送至服务器就显得非常简单了，只需将记录的属性POST到服务器即可：</p>

<pre><code>jQuery.post("/assets", asset.attributes(), function(result){
   /* 当Ajax请求成功时执行*/
});
</code></pre>

<p>如果遵守RESET的约定，我们希望在创建记录时使用POST请求、在更新记录时使用PUT请求。这就需要给Model实例增加两个方法——createRemote()和updateRemote()——使用这两个方法可以给服务器发送正确的HTTP请求：</p>

<pre><code>Model.include({
   createRemote: function(url, callback){
       $.post(url, this.attributes(), callback);
   },

   updateRemote: function(url, callback){
       $.ajax({
           url: url,
           data: this.attributes(),
           success: callback,
           type: "PUT"
       });
   }
});
</code></pre>

<p>如果在Asset实例上调用createRemote()，它的属性就会POST给服务器：</p>

<pre><code>// 用法:
Asset.init({name: "jason.txt"}).createRemote("/assets");
</code></pre>
</div>
</body>
</html>