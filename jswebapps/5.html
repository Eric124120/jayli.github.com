<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="http://a.tbcdn.cn/app/dp/s/screen.css" />
<style>
#bd {margin-left:20px;margin-right:20px;}
</style>
<title>wd-gallery - markdown</title>
</head>
<body>
<div id="bd">

<h1>第5章 视图和模板</h1>

<p>视图是应用的接口；它们为用户提供视觉呈现，并与用户产生交互。在这里的场景中，视图是无逻辑的HTML片段，由应用的控制器来管理。视图处理事件回调以及内嵌数据。可以通过直接将一些逻辑包含进视图中来打破MVC的抽象，这看起来蛮有诱惑。但不要沉迷于这种诱惑！不然会导致毫无语义的面条式代码【译注：面条式代码（Spaghetti code）是软件工程中反模式的一种，是指一个代码的控制结构复杂、混乱而难以理解，尤其是用了很多GOTO、异常、或其他组织混乱的分支结构，更多内容请参照：http://zh.wikipedia.org/wiki/面条式代码】。</p>

<p>对于工程师来说，将应用的重心从服务器端迁往客户端的过程中，视图的迁移是最繁重的工作。以往，服务器端的应用往往嵌套很多HTML片段以及新创建的页面。然而JavaScript应用中的视图则有很大不同。</p>

<p>首先，你需要将视图所需的所有数据都迁往客户端，因为你用不着再去访问服务器端变量了。最常用的方法就是用Ajax，Ajax返回一个JSON对象，然后由应用的模型载入它。你不必在服务器端对HTML作预渲染操作了，而是将渲染界面的操作全放在客户端。这使得你的客户端应用不依赖于服务器来渲染视图，这种用户界面给人感觉爽快无比。</p>

<p>然后你将数据载入到视图之中，不是通过JavaScript动态创建DOM的形式生成视图而是使用模板。本章将会着重讲解这两个主题。</p>

<h2>动态渲染视图</h2>

<p>通过JavaScript程序创建视图有多种方式，其中一种方式是使用document.createElement()创建DOM元素，设置它们的内容并将它们追加至页面中。当需要重绘视图时，只需将它清空并重复前面的过程：</p>

<pre><code>var views = document.getElementById("views");
views.innerHTML = ""; // 将元素内容清空

var container = document.createElement("div");
container.id = "user";

var name = document.createElement("span");
name.innerHTML = data.name;

container.appendChild(name);
views.appendChild(container);
</code></pre>

<p>或者，使用jQuery的API来完成相同的操作，代码更加简洁：</p>

<pre><code>$("#views").empty();

var container = $("&lt;div /&gt;").attr({id: "user"});
var name = $("&lt;span /&gt;").text(data.name);

$("#views").append(container.append(name));
</code></pre>

<p>如果待渲染的视图的内容不多的时候推荐用这种方法，可能只需创建几个DOM节点即可。将视图元素放在控制器或者状态里，其实是应用的MVC架构的一种妥协方法。</p>

<p>除了这种直接将内容拼接进DOM节点中的做法，我更推荐将静态HTML包含在页面中，在必要的时候显示或隐藏。这会让控制器中所有和视图相关的代码量降到最少，你也可以根据需要更新元素的内容。</p>

<p>举个例子，我们创建一个HTML片段用来作视图展示：</p>

<pre><code>&lt;div id="views"&gt;
    &lt;div class="groups"&gt; ... &lt;/div&gt;
    &lt;div class="user"&gt;
        &lt;span&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>现在，我们可以使用jQuery选择器来更新视图，控制多个元素的显示或隐藏：</p>

<pre><code>$("#views div").hide();

var container = $("#views .user");
container.find("span").text(data.name);
container.show();
</code></pre>

<p>使用这种方式来创建对象更加可取，因为这让视图和控制器彼此尽可能的分离开来。</p>

<h2>模板</h2>

<p>如果你经常在服务器端作套页面的工作，你对模板会很熟悉。已有很多很多模板类库——你应当根据你所用的DOM类库来选择模板类库。然而，它们的大多数都具有相似的语法，接下来会有讨论。</p>

<p>JavaScript模板的核心概念是，将包含模板变量的HTML片段和JavaScript对象作合并，把模板变量替换为对象中的属性值。总的来说，JavaScript中的模板类库的实现原理和其他语言没什么两样，比如PHP的Smarty，Ruby的REB，以及Python的字符串格式化。</p>

<p>在本书的例子中，我们使用jQuery.tmpl库作为模板引擎。如果你不想用jQuery或者想用其他不同的模板类库，这些示例代码会非常有帮助。大多数模板类库的语法即使不完全相同也非常相近。如果你想从中挑选一个不错的模板类库，可以关注下Mustache（http://mustache.github.com/），它包含很多语言的实现版本，包括JavaScript。</p>

<p>jQuery.tmpl是由微软开发的，是在John Resig【译注：John Resig是jQuery的作者】的原始工作（http://ejohn.org/blog/javascript-micro-templating/）的基础上做的模板插件。这个库目前仍在维护之中，并在jQuery官网（http://api.jquery.com/jquery.tmpl/）上有完整的文档。这个库有一个主要的方法，jQuery.tmpl()，可以给它传入一个模板和一些数据，函数会返回渲染好的元素节点，可以将渲染的结果追加至页面里。如果数据是数组的话，对于数组中的每个项都会生成渲染好的模板，否则，将只会渲染一个模板：</p>

<pre><code>var object = {
    url: "http://example.com",
    getName: function(){ return "Trevor"; }
};

var template = '&lt;li&gt;&lt;a href="${url}"&gt;${getName()}&lt;/a&gt;&lt;/li&gt;';

var element = jQuery.tmpl(template, object);
// 得到的结果: &lt;li&gt;&lt;a href="http://example.com"&gt;Trevor&lt;/a&gt;&lt;/li&gt;

$("body").append(element);
</code></pre>

<p>这里你可以看到我们使用${}语法来书写内嵌的模板变量。不管花括号中的变量名是什么，都会根据传入jQuery.tmpl()的对象来计算得出要填充的文本。你可以通过if和else语句来控制模板中的逻辑，这和纯JavaScript语法很类似。唯一的不同就是将关键字用两个花括号包裹起来，以便模板引擎可以识别它们：</p>

<pre><code>{{if url}}
    ${url}
{{/if}}
</code></pre>

<p>如果指定的属性值不是false、0、null、""、NaN或undefined就会执行if代码块。正如你所看到的，这个代码块在{{/if}}之处结束，所以不要忘掉这一点。当数组——比如说聊天消息——是空的时候显示某条消息，这时就能用到这种通用的模式了。</p>

<pre><code>{{if messages.length}}
    &lt;!-- Display messages... --&gt;
{{else}}
    &lt;p&gt;Sorry, there are no messages&lt;/p&gt;
{{/if}}
</code></pre>

<p>遍历是所有模板类库都提供的基础功能。使用模板类库的{{each}}关键字可以遍历任何JavaScript类型，包括对象和数组。如果将对象传入{{each}}，它将会基于对象的属性做遍历，同样的，将数组传入{{each}}，它也会基于数组中的每个索引进行遍历。</p>

<p>在每个片段的内部，你可以使用$value变量来访问当前正被遍历的值。显示这个值和上面的嵌入代码的示例一模一样，它用到了${$value}。看一下这个对象：</p>

<pre><code>var object = {
    foo: "bar",
    messages: ["Hi there", "Foo bar"]
};
</code></pre>

<p>然后使用接下来的模板来遍历这个message数组，显示每条消息。此外，数组元素的索引也可以使用$index变量来输出：</p>

<pre><code>&lt;ul&gt;
    {{each messages}}
        &lt;li&gt;${$index + 1}: &lt;em&gt;${$value}&lt;/em&gt;&lt;/li&gt;
    {{/each}}
&lt;/ul&gt;
</code></pre>

<p>正如代码中所示，jQuery.tmpl模板API非常简单直接。大多数可选的模板类库API都大同小异，当然也有一些模板提供高级特性，比如lambda表达式【译注：lambda表达式也叫做λ演算，更多内容请参照http://zh.wikipedia.org/wiki/Λ演算】、局部模板【译注：局部模板就是模板中包含的模板片段】和注释。</p>

<h3>模板Helper</h3>

<p>有时在视图内部使用“通用helper函数“（generic helper function）是非常好用的，比如格式化一个日期或数字。然而我们仍要保持良好的MVC架构的思路，而不是直接在视图中任意添加感兴趣的函数。比如，让我们来替换一段纯文本中的<a></a>标签里的链接。通常我们会像下面这段代码这样做，但这是一种错误的方法：</p>

<pre><code>&lt;div&gt;
    ${ this.data.replace(
/((http|https|ftp):\/\/[\w?=&amp;.\/-;#~%-]+(?![\w\s?&amp;.\/;#~%"=-]*&gt;))/g,
'&lt;a target="_blank" href="$1"&gt;$1&lt;/a&gt; ') }
&lt;/div&gt;
</code></pre>

<p>我们应当将它抽象出来，并用命名空间进行管理，而不是直接将函数掺杂进视图中，这样才能保持逻辑和视图之间的解偶。在这个例子中，我们来创建一个单独的helper.js文件，这个文件包含应用所有的工具函数，比如autoLint()函数。这样就可以通过这个helper来整理我们的视图：</p>

<pre><code>// helper.js
var helper = {};
helper.autoLink = function(data){
    var re = /((http|https|ftp):\/\/[\w?=&amp;.\/-;#~%-]+(?![\w\s?&amp;.\/;#~%"=-]*&gt;))/g;
    return(data.replace(re, '&lt;a target="_blank" href="$1"&gt;$1&lt;/a&gt; ') );
};

// template.html
&lt;div&gt;
    ${ helper.autoLink(this.data) }
&lt;/div&gt;
</code></pre>

<p>这里还有一个额外的好处，autoLink()函数是通用的，在应用的任何地方都可以使用它。</p>

<h3>模板存储</h3>

<p>说到模板的存储，有这样一些内容需要考虑：</p>

<ul>
<li>在JavaScript中以行内形式存储</li>
<li>在自定义script标签里的行内形式存储</li>
<li>远程加载</li>
<li>在HTML中以行内形式存储</li>
</ul>

<p>其中一些非常适合在MVC架构中使用，我个人推荐使用第二种方式，即在自定义script标签里的行内形式存储模板，原因接下来会给出。</p>

<p>你可以将模板保存在JavaScript文件中，但并不推荐这样做，因为这需要将视图的代码放入一个控制器中，这违背MVC架构的原则。</p>

<p>你可以根据需要来通过Ajax请求动态的加载模板。这种方法的好处是初始化页面的体积非常小，缺点是在模板加载时UI的渲染变的很慢。使用JavaScript来构建应用的主要原因就是速度问题，所以使用Ajax加载模板时就要非常小心，如果因此降低了UI的渲染速度则显得得不偿失了。</p>

<p>你还可以将模板保存在页面的HTML中，以行内的形式保存。这种方法的好处是它不存在UI加载缓慢的问题，这样就避免了通过Ajax加载模板造成的用户体验上的损失。源代码也更加清晰，模板就在它们将要展示的位置以行内的形式存放。这种方式的缺点也很显而易见，它增加了初始页面的体积。坦白讲，这种体积增加造成的性能损失微不足道，特别是当服务器开启了压缩和缓存的情况下，就更不值得一提了。</p>

<p>我推荐使用自定义script标签来存放模板，通过JavaScript的ID来获取模板的引用。这种存放模板的方法非常方便，特别是当你想在很多地方使用它们时。自定义script标签还有一个好处就是，浏览器不必对它们进行渲染，而仅将它们解析为内容文本。</p>

<p>如果在页面中以行内形式定义了模板，你可以使用jQuery.fn.tmpl(data)方法来调用，也就是说在jQuery元素上调用tmpl()方法：</p>

<pre><code>&lt;script type="text/x-jquery-tmpl" id="someTemplate"&gt;
    &lt;span&gt;${getName()}&lt;/span&gt;
&lt;/script&gt;

&lt;script&gt;
    var data = {
        getName: function(){ return "Bob" }
    };
    var element = $("#someTemplate").tmpl(data);
    element.appendTo($("body"));
&lt;/script&gt;
</code></pre>

<p>在程序的后台，jQuery.tmpl会确保模板一旦生成后，解析后的模板就能被缓存住。这将提高程序的运行效率，因为再次使用模板的时候不必第二次解析它们。注意，我们首先根据内容生成元素然后将它追加到页面中，这种方式性能更加，不要操作已经追加至页面的元素，这是一种最佳实践。</p>

<p>尽管你还是渲染了所有在页面中以行内形式保存的模板，这并不意味着服务器端也要遵从这种结构。尽可能的将每个模板放入一个单独的文件中，然后在页面请求的时候拼接进文档中。在第6章将要讲到的一些“依赖管理工具“会帮你完成这个工作，比如RequireJS。</p>

<h2>绑定</h2>

<p>从绑定开始，你开始感觉到客户端渲染视图的切实好处。本质上讲，绑定将视图元素和JavaScript对象（通常是模型）挂接在一起。当JavaScript对象发生改变时，视图会根据新修改后的对象做适时更新。换句话说，一旦你将视图和模型绑定在一起，则当应用的模型更新时视图也会自动渲染。</p>

<p>绑定是一件“大事“。它意味着当记录发生改变时你的控制器不必处理视图的更新，因为这些更新都是在后台自动完成的。使用绑定来架构你的应用同样为构建实时应用打下了基础。在第8章会对实时应用作进一步阐述。</p>

<p>因此，为了将JavaScript对象和视图绑定在一起，我们需要设置一个回调函数，当对象的属性发生改变时发送一个更新视图的通知。问题是JavaScript并没有提供原生方法支持。JavaScript中也不像Ruby和Python一样提供了method_missing功能。并且也不可能使用JavaScript的getter和setter（http://ejohn.org/blog/javascript-getters-and-setters/）来模拟这种行为。但要知道JavaScript是一门极其灵活的动态语言，我们可以直接写change回调：</p>

<pre><code>var addChange = function(ob){
    ob.change = function(callback){
        if (callback) {
            if ( !this._change ) this._change = [];
            this._change.push(callback);
        } else {
            if ( !this._change ) return;
            for (var i=0; i &lt; this._change.length; i++)
                this._change[i].apply(this);
        }
    };
};
</code></pre>

<p>这里的addChange()函数将change()函数添加至传入的任意对象中。这里的change()函数的运行和jQuery中的change事件是一模一样的。你可以通过调用change()来添加回调，或者通过调用change()来触发事件，不用带入任何参数。来看一个实际的例子：</p>

<pre><code>var object = {};
object.name = "Foo";

addChange(object);
object.change(function(){
    console.log("Changed!", this);
    // 这里可以添加更新视图的代码
});

object.change();

object.name = "Bar";
object.change();
</code></pre>

<p>因此可以看到我们给这个对象添加了change()回调，这样就可以执行绑定和触发change事件了。</p>

<h3>模型中的事件绑定</h3>

<p>现在我们把刚才绑定的例子更进一步，把它应用于模型里。当模型记录创建、更新或销毁时，都会触发change事件，并重新渲染视图。在下面的例子中，我们创建了一个基础的User类，新建了事件绑定和触发，最后监听了change事件，当触发change事件时重新渲染视图：</p>

<pre><code>&lt;script&gt;
    var User = function(name){
        this.name = name;
    };
    User.records = []

    User.bind = function(ev, callback) {
        var calls = this._callbacks || (this._callbacks = {});
        (this._callbacks[ev] || (this._callbacks[ev] = [])).push(callback);
    };

    User.trigger = function(ev) {
        var list, calls, i, l;
        if (!(calls = this._callbacks)) return this;
        if (!(list = this._callbacks[ev])) return this;
        jQuery.each(list, function(){ this() })
    };

    User.create = function(name){
        this.records.push(new this(name));
        this.trigger("change")
    };

    jQuery(function($){
        User.bind("change", function(){
            var template = $("#userTmpl").tmpl(User.records);
            $("#users").empty();
            $("#users").append(template);
        });
    }):
&lt;/script&gt;

&lt;script id="userTmpl" type="text/x-jquery-tmpl"&gt;
    &lt;li&gt;${name}&lt;/li&gt;
&lt;/script&gt;

&lt;ul id="users"&gt;
&lt;/ul&gt;
</code></pre>

<p>现在无论何时修改User的记录，User的模型的change事件都会被触发，调用我们模板的回调函数并重绘用户列表。这很有帮助，因为我们只需关注创建和更新用户的记录，而不必担心视图的更新，视图的更新是自动的。比如，我们创建一个新的User：</p>

<pre><code>User.create("Sam Seaborn");
</code></pre>

<p>这时User的change事件会被触发，我们的模板会重新渲染，自动将新添加的User更新至视图里。你可以在这里看到完整的模型绑定的示例代码：assets/ch05/model.html.</p>
</div>
</body>
</html>