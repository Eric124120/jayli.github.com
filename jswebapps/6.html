<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="http://a.tbcdn.cn/app/dp/s/screen.css" />
<style>
#bd {margin-left:20px;margin-right:20px;}
</style>
<title>wd-gallery - markdown</title>
</head>
<body>
<div id="bd">

<h1>第6章 依赖管理</h1>

<p>JavaScript中缺失了很多计算机高级编程语言所应有的功能特性，其中一个重要的特性就是依赖管理和模块系统。和其他编程语言不同，对于很多学习JavaScript的人来说，并不会过多关注命名空间和模块化等这些传统的重要知识点。实际上，诸如jQuery之类的流行类库亦不会增强应用的架构性。开发者需要自己解决“应用架构”的问题。我见到过太多太多面条式JavaScript代码了，这类代码的缩进排版近乎疯狂，包含数不清的匿名函数的嵌套，这种代码是不是似曾相识？</p>

<pre><code>function() {
    function() {
        function() {
            function() {
            }
        }
    }
}
</code></pre>

<p>构建巨型应用当然需要引入模块化和命名空间，但还不得不考虑另外一个问题——内置的依赖管理系统。很长一段时间内，我们以为只用JavaScript标签就足够了，毕竟页面中使用的JavaScript代码并不涉及太多的维护和扩展。但当你开始写复杂的JavaScript应用的时候，就必须引入依赖管理系统了。手动维护页面的中script标签之间的依赖关系根本不可行。代码会变得混乱不堪，看起来像这样：</p>

<pre><code>&lt;script src="jquery.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="jquery.ui.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="application.utils.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="application.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="models/asset.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="models/activity.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="states/loading.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="states/search.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- ... --&gt;
</code></pre>

<p>依赖管理系统除了能解决实际的编程复杂度和可维护性的问题，还能解决性能方面的问题。浏览器需要针对每个JavaScript文件都发起一个HTTP请求，尽管可以将这些请求放入异步队列，但大量的HTTP连接总会造成性能的下降，每个连接都包含额外的HTTP头信息、cookies、并都要做TCP的三次握手【译注：如果服务器开启Connection:keep-alive的话，是可以一定程度上减少TCP三次握手的次数的】。当你的应用是基于SSL【译注：安全套接层（Secure Sockets Layer，SSL）是网景公司（Netscape）在推出Web浏览器首版的同时，提出的协议。SSL采用公开密钥技术，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听，更多内容参照http://zh.wikipedia.org/wiki/传输层安全】提供服务的话，情况会更加糟糕。</p>

<h2>CommonJS</h2>

<p>当大家开始关注如何将JavaScript应用于服务器端时，引入了很多解决依赖管理问题的建议方法。SpiderMonkey和Rhino提供了load()函数，但并没有很好的解决命名空间的问题。Node.js提供了require()函数用来加载外部资源文件，Node.js自有的模块系统也使用这种方式来管理。但代码的可移植性并不好，所以当你想在Node.js中运行Rhino的代码时会不会出问题呢？</p>

<p>为了让代码更具可移植性，则亟需引入一个标准解决方案，让所有的JavaScript都能遵照这个标准实现统一的模块管理系统，这样JavaScript代码库就可以运行在所有的环境中了。Kevini Dangoor按照这个思路提出了CommonJS规范。它在一篇博客（http://goo.gl/voRNb）中首次提出一个公开的标准，这个标准适用于JavaScript解释器和开发者，他对此做了一些说明：</p>

<blockquote>
  <p>JavaScript需要一个标准的方法来解决加载外部模块和用命名空间的方式谨慎管理模块的问题。命名空间的问题很容易解决。但并没有标准的编程模式来解决（一次性）加载模块的问题。</p>
  
  <p>这不是一个技术问题，而是需要我们在一起共同讨论并达成一致给出构建大型应用的通用方法，群策群力齐力断金才能让这个标准影响范围更广、看起来更酷。</p>
</blockquote>

<p>随着邮件列表的建立，CommonJS（http://www.commonjs.org/）诞生了。随后越来越多的重要组织相继加入，它的发展非常快，很快成为了JavaScript模块写法的事实标准。它包含很多标准，包括IO接口、底层的套接字流（Socket stream），以及单元测试。</p>

<h3>模块的声明</h3>

<p>声明CommonJS模块非常简单直接。命名空间的概念也被融入在内。模块被分隔为不同的文件，通过给exports对象添加内容来对外暴露模块的变量和方法，exports变量是在解释器中定义好的：</p>

<pre><code>// maths.js
exports.per = function(value, total) {
    return( (value / total) * 100 );
};

// application.js
var Maths = require("./maths");
assertEqual( Maths.per(50, 100), 50 );
</code></pre>

<p>要想使用在模块中定义的函数，只需require()这个文件即可，同时将运行结果保存在本地变量中。在上面的例子中，maths.js中暴露的方法都存在于Maths变量中，可以看到模块就是命名空间，并且这种代码可以在所有遵循CommonJS规范的JavaScript解释器中运行，比如Narwhal（http://narwhaljs.org/）和Node.js。</p>

<h3>模块和浏览器</h3>

<p>那么，如何在客户端JS中也实现CommonJS呢？因为很多开发者发现在客户端实现的模块加载器和服务器端有所不同，也就是说如果遵照现行版本的CommonJS规范，模块都是以异步的方式加载的。在服务器端可以完美的实现CommonJS规范，但在浏览器端实现CommonJS就不那么容易了，因为它需要阻塞UI并适时的执行刚加载的script脚本（在客户端则需要避免这种情况的出现）。CommonJS团队为此提出了一个规范：“模块转换格式“（http://goo.gl/Vd1vD）。这种转换格式将CommonJS的模块包装在一个回调函数中，以便更好的处理客户端的异步加载【译注1】。</p>

<p>【译注1：在客户端里，为了处理模块依赖关系不得不将模块主逻辑包含在某个回调函数中，加载模块的过程实际是“保存回调“的过程，最后统一处理这些回调函数的执行顺序。作为模块加载器鼻祖的YUILoader便是遵循这种逻辑实现的，并在YUI3中形成了其独具特色的use()和add()模块化编程风格。为了便于理解客户端的模块加载器基本原理，可以参照译者实现的一个小型的类库Sandbox.js（https://github.com/jayli/sandbox），文档中详细讲解了模块加载器的基本原理】</p>

<p>我们将上一个例子做一些改进。将它包装进一个“转换格式“里，以启用异步加载，这样就可以完美支持浏览器了：</p>

<pre><code>// maths.js
require.define("maths", function(require, exports){
    exports.per = function(value, total) {
        return( (value / total) * 100 );
    };
});

// application.js
require.define("application", function(require, exports){

    var per = require("./maths").per;
    assertEqual( per(50, 100), 50 );

}), ["./maths"]); // 给出它的依赖 (maths.js)
</code></pre>

<p>这样就可以通过在浏览器中引入模块加载器来管理并执行我们的模块了。这对我们管理代码带来很多便利，我们可以将代码分隔成模块组件，这是做良好的应用架构设计的秘诀之一，同时我们还获得了依赖管理的支持，包括独立的作用域和命名空间。没错，相同的模块可以运行在浏览器、服务器、桌面应用、以及任何支持CommonJS的环境中。换句话说，现在就可以在客户端和服务器端之间共享代码了！</p>

<h2>模块加载器</h2>

<p>为了在客户端使用CommonJS模块，我们需要引入模块加载器类库。当然可选的库还有很多，每个类库都各有其优缺点。这里我会讲到多数流行的类库，你可以根据你的需要自行选择合适的类库【译注2】。</p>

<p>【译注2：这里向大家强烈推荐模块加载器SeaJS（http://seajs.com/），SeaJS开创性的在客户端实现了同步require()，使得在客户端也能遵循CommonJS标准规范进行编码开发，当然，SeaJS作为客户端的一个类库，仍然存在着无法回避的问题，比如伪阻塞。因此使用SeaJS作开发时需要遵守一些额外的约定（http://seajs.com/docs/zh-cn/rules.html）】</p>

<p>CommonJS模块格式目前还在修订之中，还有很多提议没有处理。就目前来看，并未有真正完美的官方的模块加载约定，很遗憾，缺少统一的标准会让情况变得更复杂。目前最主要最广泛的两个模块实现是 Transport C（http://goo.gl/iaksA）和Transport D（http://goo.gl/An9qK）。如果你采用了接下来要讲的任意一个模块加载器类库的话，你必须确保你实现模块的代码格式遵循你所采用加载器所支持的格式规范。幸运的是，很多模块加载器的包装工具【译注：原文是wrapping tools，指的是包裹你的模块逻辑代码的最外层的添加模块的语法】可以兼容，而且会在们各自的文档中给出所支持的包装写法。</p>

<h3>Yabble</h3>

<p>Yabble（http://goo.gl/1A3d1）是一款优秀的轻量级的模块加载器。你可以配置Yabble来支持通过XHR加载模块或者使用script标签来加载模块。通过XHR来抓取模块的优势是你不必再用转换格式把模块再包装一层了。然而，这种做法的缺点是必须用eval()来执行模块代码，调试器来很不方便。另外还会遇到跨域的问题，尤其是当使用了CDN【译注：CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定，比如雅虎所用的cn.yimg.com和淘宝使用的a.tbcdn.cn，都属于CDN】的时候。理想情况是，应当使用XHR来实现一些“快餐式”【译注：原文是quick and dirty，意思是“一种迅速而又随性的“，专指用快速且肮脏的手法来实现一些功能，虽然性能和可维护性都很糟糕，但的确很有效的完成功能】的开发，而不是严谨规范的开发：</p>

<pre><code>&lt;script src="https://github.com/jbrantly/yabble/raw/master/lib/yabble.js"&gt; &lt;/script&gt;
&lt;script&gt;
    require.setModuleRoot("javascripts");

    // 如果模块通过转换格式作了包装
    // 那么我们就可以使用script标签
    require.useScriptTags();

    require.ensure(["application"], function(require) {
        // 应用加载完毕
    });
&lt;/script&gt;
</code></pre>

<p>这个例子中，程序会抓取包装后的application模块然后加载它的依赖utils.js，之后才开始运行这个模块。我们可以使用require()函数来加载模块：</p>

<pre><code>&lt;script&gt;
    require.ensure(["application", "utils"], function(require) {
        var utils = require("utils");
        assertEqual( utils.per( 50, 200 ), 25 );
    });
&lt;/script&gt;
</code></pre>

<p>尽管utils被引用了两次，一次被内联的require.ensure()函数引用，另一次被application模块所引用，我们的脚本非常聪明，可以只加载它一次。但必须确保你的模块所需的所有依赖都加上了转换格式。</p>

<h3>RequrieJS</h3>

<p>RequireJS是Yabble的一个不错的替代品，它是现在最流行的加载器之一。RequireJS对模块加载的看法略有不同，它遵循“异步模块定义“（Asynchronous Module Definition，简称AMD）格式。主要的不同之处在于AMD的API是即时计算依赖关系，而不是延迟计算。实际上，RequireJS完全和CommonJS的模块相互兼容，只是包装转换的写法格式不同【译注3】。</p>

<p>【译注3：关于AMD规范到底是一种“模块书写格式”（Module Authoring Format）还是一种“转换格式”（Transport Format）一直存在争议】</p>

<p>为了加载JavaScript文件，只需将它们的路径传入require()函数即可，并指定一个回调函数，当依赖都加载完成后执行这个回调函数：</p>

<pre><code>&lt;script&gt;
    require(["lib/application", "lib/utils"], function(application, utils) {
        // 加载完成!
    });
&lt;/script&gt;
</code></pre>

<p>在这个例子中可以看出，application和utils模块是以回调参数的形式传入的，而不必使用require()函数来获取它们。</p>

<p>你能引用的不光是模块，RequireJS同样支持原始的JavaScript类库以依赖的形式载入，尤其是jQuery和Dojo。其他的类库可以正常工作，但它们不会以参数形式正确的传入所需的回调函数中。然而，任何以依赖形式载入的类库都需要使用模块格式写法：</p>

<pre><code>require(["lib/jquery.js"], function($) {
    // jQuery 加载完毕
    $("#el").show();
});
</code></pre>

<p>传入require()的路径是相对于当前文件或模块的路径，除非路径的前缀是/。出于最优化的考虑，RequireJS推荐你将初始脚本加载器放入一个单独的文件中，这个迷你的类库甚至提供了一种快捷的引入方式：data-main属性：</p>

<pre><code>&lt;script data-main="lib/application" src="lib/require.js"&gt;&lt;/script&gt;
</code></pre>

<p>设置script标签的data-main属性是告知RequireJS直接调用require()，将这个属性值以参数传入require()中，在这个例子中，它将会调用lib/application.js脚本，它还会加载我们应用所需的其他脚本：</p>

<pre><code>// lib/application.js
require(["jquery", "models/asset", "models/user"], function($, Asset, User) {
    //...
});
</code></pre>

<p>我们刚刚讲了加载模块的方式，那么如何定义模块呢？上文已经提到，RequireJS使用一种完全不同的语法来定义模块。不是使用require.define()，而是直接使用define()函数。因为模块都在不同的文件中，因此用不着使用显式的命名。第一个参数是它的依赖，是一个字符串组成的数组，随后的参数是一个回调函数，回调函数中包含实际的模块逻辑，和RequireJS的require()函数类似，依赖的内容以参数的形式传给回调函数：</p>

<pre><code>define(["underscore", "./utils"], function(_, Utils) {
    return({
        size: 10
    })
});
</code></pre>

<p>默认情况下是没有exports变量的。如果要从模块中暴露一些变量只需将数据从函数中返回即可。RequireJS的模块有一个优势，就是它们已经是被包装好的，因此你不必担心为了兼容浏览器再去写转换格式。然而，需要注意的是，这个API并不兼容CommonJS的模块，即不能写一个模块代码同时运行在Node.js中和浏览器中。其实是可以做一些简单的hack来让CommonJS的模块代码运行在客户端，RequireJS为CommonJS提供了一个“容错层“——只需将现有的模块代码外部用define()函数包装一层即可：</p>

<pre><code>define(function(require, exports) {
    var mod = require("./relative/name");

    exports.value = "exposed";
});
</code></pre>

<p>回调函数的参数必须和这段示例代码中所示的一模一样，require和exports。你的模块就可以照常使用这些变量了，而不用作任何改动。</p>

<h2>包装模块</h2>

<p>现在我们有了管理模块依赖和命名空间的方法，但仍然有一个问题自始至终都没有解决，每个文件都独占一个HTTP请求。我们依赖的所有模块都从远程加载，尽管是以异步的形式，还是会造成很严重的性能问题，将应用的启动时间推后。</p>

<p>对于需要异步加载的模块，我们手动将模块包装成一种转换格式，这种做法看起来也很冗余。可以在服务器端将小文件合并为一个文件输出，这种做法一箭双雕。这样浏览器只需发起一个HTTP请求来抓取一个资源文件就能将所有的模块都载入进来，显然这种做法更高效。使用打包工具也是一种聪明的做法，这样就不必随意无组织的打包模块了，而是静态分析这些文件然后递归的计算它们的依赖关系。它们会同样会将不符合要求的模块包装成转换格式，这样就不必手动敲代码了。</p>

<p>除了在服务器端合并代码，很多模块打包工具也支持代码的压缩（minify），进一步减少请求的体积。实际上，一些工具——比如rack-modulr（http://goo.gl/0YcFK）和Transporter（http://goo.gl/Exkpm）——已经整合进了Web服务器，当首次处理某个请求时会自动处理模块操作【译注4】。</p>

<p>【译注4：随着应用体积越来越庞大，考虑到可维护性需要将模块作很细的颗粒化，文件会拆分成很多个，考虑到性能又不得不将文件合并载入，两者是一对矛盾，所以模块依赖管理既要考虑到代码结构的整洁清晰又要兼顾性能最优化，文中提到的方法就是在努力寻求两者之间的最佳权衡。雅虎和淘宝都已经实现了基于CDN的静态文件合并（combo）输出功能，使用YUI3或KISSY的加载器来计算合并输出的url，是解决这一对矛盾的一种尝试】</p>

<p>例如，这里是一段简单的Rack CommonJS模块服务示例代码，它使用rack-modulr来实现：</p>

<pre><code>require "rack/modulr"

use Rack::Modulr, :source =&gt; "lib", :hosted_at =&gt; "/lib"
run Rack::Directory.new("public")
</code></pre>

<p>可以使用rackup命令来启动服务。所有CommonJS模块都包含在lib文件夹中，它们会根据依赖关系自动合并成一个文件并包装进一个转换回调中。我们的脚本加载器根据需要发起对模块的请求，将他们载入到页面中：</p>

<pre><code>&gt;&gt; curl "http://localhost:9292/lib/application.js"
    require.define("maths"....
</code></pre>

<p>如果你不熟悉Ruby的话，还有很多其他的选择。FlyScript（http://www.flyscript.org/）是用PHP写的一个CommonJS模块包装器，Transporter是基于JSGI（http://jackjs.org/）服务器的转换器，Stitch（http://goo.gl/uRmtQ）整合入了Node.js服务器。</p>

<h2>模块的按需加载</h2>

<p>你可能不想用模块化的方式来写代码，或许因为你现有的代码和库要改成用模块化的方法来管理需要作太多改动。幸运的是，还有很多其他的替代方案，比如Sprockets。Sprockets给你的JavaScript代码添加了同步require()支持。以<code>//=</code>形式书写的注释指令都会被Sprockets作预处理。比如，<code>//=require</code>指令通知Sprockets来检查类库的加载路径，加载它并以行内形式包含进来：</p>

<pre><code>//= require &lt;jquery&gt;
//= require "./states"
</code></pre>

<p>在这个例子中，jquery.js是Sprockets所需的加载地址，states.js是以相对路径的形式给出的。Sprockets非常聪明，它会保证只加载库文件一次，自动忽略掉之后的加载需求。相比于CommonJS模块，Sprockets支持缓存和压缩（minify）。在开发过程中，你的服务器会根据页面的需要动态解析并合并文件。当站点的访问非常频繁时，JavaScript文件可以被预合并，这样就可以作为静态文件来处理，从而提高了性能。</p>

<p>尽管Sprockets是一个基于命令行的工具，但也有一些工具集成进了Rack和Rails，比如rack-sprockets（http://goo.gl/cJSLR）。甚至还有一些PHP的实现（http://goo.gl/0HvwT），Sprockets（包括所有的模块包装器）的中心思想是，所有的JavaScript文件都需要预处理，不管是用在服务器端用程序做处理还是使用命令行工具作处理。</p>

<h3>LABjs</h3>

<p>LABjs是最简单的模块依赖管理器【译注5】。它不需要任何服务器支持和CommonJS模块支持。使用LABjs载入你的脚本代码减少了页面加载过程中的资源阻塞，这是一种极其简单且极为有效的性能优化的方法。默认状况下，LABjs会尽可能快速的以并行方式加载脚本。然而如果代码之间有依赖关系的话，也可以非常简单的指定他们的执行顺序：</p>

<p>【译注5：作者这里将LABjs归类为”依赖管理器“有些勉强，LABjs给自己的定位是”脚本加载器“，主要是为了解决加载脚本时的性能问题】</p>

<pre><code>&lt;script&gt;
    $LAB
    .script('/js/json2.js')
    .script('/js/jquery.js').wait()
    .script('/js/jquery-ui.js')
    .script('/js/vapor.js');
&lt;/script&gt;
</code></pre>

<p>在这个例子中，所有的脚本加载都是并行的，但LABjs会确保jquery.js在jquery-ui.js和vapor.js之前加载并执行。它的API非常简单且简洁明了，如果想了解LABjs更多的高级特性，比如LABjs如何支持行内脚本，可以查看它的文档：http://labjs.com/documentation.php。</p>

<h2>无交互行为内容的闪烁（FUBC）</h2>

<p>使用这些加载器来加载页面时有一点需要尤为注意，用户可能会看到页面会闪烁一下，出现一部分没有交互行为的内容快速闪过（FUBC），比如在JavaScript执行之前会有一部分无样式的页面原始内容闪烁一下。如果你不依赖JavaScript来修改初始页面的样式的话，问题其实并不严重。但如果依赖JavaScript来操作样式，则需要将样式提取出来放入初始化CSS之中，比如隐藏一些元素或展示一个加载指示器，提示页面正在加载中。</p>
</div>
</body>
</html>