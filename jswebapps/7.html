<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="http://a.tbcdn.cn/app/dp/s/screen.css" />
<style>
#bd {margin-left:20px;margin-right:20px;}
</style>
<title>wd-gallery - markdown</title>
</head>
<body>
<div id="bd">

<p><style>
p img {
        float:none;
}
</style></p>

<h1>第7章 使用文件</h1>

<p>以往，文件的访问和操作都是基于桌面应用程序，在Web中操作文件必须借助第三方插件技术，比如Adobe Flash。然而随着HTML5的普及和推广，基于Web应用的文件操作不再变得遥不可及，HTML5赋予开发者更多权限来处理文件，这进一步打破了桌面应用和Web应用之间的界限。在现代浏览器中，用户可以直接将文件拖拽进页面中，粘贴格式化数据，实时查看上传文件的进度。</p>

<h2>浏览器支持</h2>

<p>不是所有的浏览器都支持新的HTML5文件API，但现在已经有足够多的浏览器都实现了这一特性，你完全可以将文件操作的功能添加至你的应用中：</p>

<ul>
<li>Firefox >= 3.6</li>
<li>Safari >= 6.0</li>
<li>Chrome >= 7.0</li>
<li>IE: no support</li>
<li>Opera >= 11.1</li>
</ul>

<p>由于IE还不支持这一特性，你需要使用渐进增强的理念来处理文件操作，给用户提供传统的文件上传功能，同时允许在支持文件操作的浏览器中使用文件拖拽功能。特性检测也很简单，只需检查相关的对象是否存在即可：</p>

<pre><code>if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList) {
    // 支持文件操作 API
}
</code></pre>

<h2>获取文件信息</h2>

<p>HTML5的文件操作有一定的安全限制，主要的限制是只有被用户选中的文件才能被访问。将文件拖拽至浏览器中、选择要输入的文件、或将文件粘贴至Web应用中，这些操作自然会满足这个安全限制。尽管已经有人实现了“基于JavaScript的文件系统“（http://www.html5rocks.com/en/tutorials/file/filesystem/），但这里的访问都是基于沙箱的。显然，允许JavaScript任意无限制的操作文件会带来很严重的安全风险。</p>

<p>在HTML5中使用File对象来表示文件，它有三个属性：</p>

<ul>
<li>name：文件名，这是一个只读字符串</li>
<li>size：文件大小，这是一个只读的整数</li>
<li>type：文件的MIME类型，是一个只读字符串，如果类型没有指定的话就是空字符串</li>
</ul>

<p>出于安全的原因，文件的路径是无法得到的。</p>

<p>可以通过FileList对象来获取多个文件，可以把它当作File对象组成的数组来看待。</p>

<h2>文件输入</h2>

<p>从Web诞生之日起就包含了文件输入的功能，用户可以使用这个传统的功能来上传文件。HTML5增强了这一功能，修正了很多缺陷。对于开发者来说，长期以来很让人头疼的是多文件上传。过去开发者只能堆积很多文件输入框或者依赖插件（Flash）来实现多文件上传。HTML5提供了multiple属性来支持多文件。给文件输入框指定multiple属性告知浏览器可以使用它来选择多个文件。旧版本的浏览器如果不支持HTML5则会忽略这个属性：</p>

<pre><code>&lt;input type="file" multiple&gt;
</code></pre>

<p>但UI并不完美，用户可以按住Shift键来多选文件。有时你需要为这个效果增加一些提示，比如，Fackbook发现85%的用户上传照片的时候，每次只上传一张（http://www.zurb.com/article/515/podcast-of-julie-zhuos-talk-on-how-facebo）。可以在上传过程中给出如何上传多个照片的提示，比如图7-1，这个比例从85%降到了40%。</p>

<p>对于开发者来说还有一个棘手的问题，他们不知道当前选中了哪些文件。往往我们需要添加一些诸如验证选中文件合法性的功能，确保所选文件类型和大小都是正确的。HTML5提供了接口可以获得选中文件的信息，这用到了files属性。</p>

<p>files属性是只读的，它返回一个FileList，可以用它对文件作遍历，逐一对它们作验证，并将验证结果通知给用户。</p>

<pre><code>var input = $("input[type=file]");

input.change(function(){
    var files = this.files;

    for (var i=0; i &lt; files.length; i++)
        assert( files[i].type.match(/image.*/) )
});
</code></pre>

<p><img src="http://img01.taobaocdn.com/tps/i1/T1H5yvXoRWXXXXXXXX-555-244.png" alt="图7-1" /></p>

<p>图7-1. Fackbook的多文件上传</p>

<p>访问选中的文件不会有任何限制，比如你可以读取文件内容，显示上传预览。或者可以使用Ajax在后台执行上传，这样就不会像传统上传文件那样阻塞UI。在后台上传文件还可以实时显示进度条。在接下来的章节会对此详细讨论。</p>

<h2>拖拽</h2>

<p>早在1999年，微软的IE5就“设计“并实现了最原始的拖拽，自那时起后续的IE版本都支持拖拽。HTML5规范刚刚增加了拖拽的内容，现在Safari，Firefox和Chrome也都模仿IE的实现做到了拖拽支持。然而，坦白讲HTML5的规范并不明晰，需要重新整理。</p>

<p>关于拖拽的事件至少有七个：dragstart, drag, dragover, dragenter, dragleave, drop, 和 dragend。接下来会对每个事件作详细讲解。</p>

<p>即使你的浏览器不支持HTML5的文件API，但你仍可继续使用拖拽API。当前的浏览器支持情况如下：</p>

<ul>
<li>Firefox >= 3.5</li>
<li>Safari >= 3.2</li>
<li>Chrome >= 7.0</li>
<li>IE >= 6.0</li>
<li>Opera: no support</li>
</ul>

<h3>拖拽</h3>

<p>拖拽【译注：Drag和Drop在不引起歧义时统一译为“拖拽”，其实这个词组是由Drag（拖拽）和Drop（释放拖拽）组成，本小节标题是Dragging，特指区别于“释放拖拽”的“拖拽”】非常简单。可以给元素设置draggable属性为true来启用元素的拖拽。</p>

<pre><code>&lt;div id="dragme" draggable="true"&gt;Drag me!&lt;/div&gt;
</code></pre>

<p>现在我们给可拖拽的元素关联一些数据。我们可以监听dragstart事件并调用事件的setData()函数：</p>

<pre><code>var element = $("#dragme");

element.bind("dragstart", function(event){
    // 我们不想使用jQuery的抽象方法
    event = event.originalEvent;

    event.dataTransfer.effectAllowed = "move";
    event.dataTransfer.setData("text/plain", $(this).text());
    event.dataTransfer.setData("text/html", $(this).html());
    event.dataTransfer.setDragImage("/images/drag.png", -10, -10);
});
</code></pre>

<p>jQuery提供了一个抽象的事件【译注：为了处理底层API的差异性，通常将底层对象作封装，对外提供统一的接口，这是一种常见的编程模式，被称为“门面模式”(facade)，jQuery和YUI3的事件都是包装后的“门面”，作者此处提到的抽象事件就是指这个“门面”】，它不包含我们需要的dataTransfer对象。但为了方便起见这个抽象对象提供了originalEvent 属性，我们可以通过它来访问拖拽（drag/drop）API。</p>

<p>刚才提到，事件包含dataTransfer对象，其中包含拖拽和释放拖拽所需的方法。通过setData()函数可以设置“互联网媒体类型“（MIMEType）和一个字符串数据。在这个例子中，我们给drag事件设置了text和text/html数据。当元素释放拖拽，就会触发drop事件，这时可以读取这个数据。与之类似，如果元素拖拽到浏览器的外部，其他的应用也可以根据它们支持的文件类型来处理释放拖拽的数据。</p>

<p>当拖拽文本时使用text/plain类型。推荐将应用的反馈类型总是设置为此类型，如果释放拖拽的目标不支持其他格式时也设置为text/plain类型。拖拽的链接包含两种格式：text/plain和text/uri-list。通过将每个链接合并为一个新行来拖拽多个链接：</p>

<pre><code>// 拖拽链接
event.dataTransfer.setData("text/uri-list", "http://example.com");
event.dataTransfer.setData("text/plain", "http://example.com");

// 拖拽多个链接
event.dataTransfer.setData("text/uri-list", "http://example.com\nhttp://google.com");
event.dataTransfer.setData("text/plain", "http://example.com\nhttp://google.com");
</code></pre>

<p>setDragImage()函数是可选的，用它可以设置拖拽操作过程中跟随鼠标移动的的图片，它的参数是图片源地址和x/y坐标，这个坐标是相对于鼠标位置的。如果没有提供，则会将拖拽的元素拷贝一份并显示为半透明。除了setDragImage()之外还可以使用addElement(element,x,y)，它使用给定的元素来更新被拖拽的元素。换句话说，你可以为拖拽操作的过程自定义要显示的元素。</p>

<p>你同样可以让用户拖拽浏览器之外的文件，只需设置DownloadURL类型即可。你可以将URL指定为文件路径，浏览器随后会将它下载下来。Gmail实现了类似这种功能，特效非常棒，可以让用户将邮件附件从浏览器中拖拽至桌面。</p>

<p>坏消息是，只有Chrome支持这个特性，这个特性还在修订之中。但不影响使用，在不久的将来其他的浏览器也会陆续加入对这个特性的支持。DownloadURL值的格式是由冒号（:）分隔的文件列表信息：媒体类型（MIME），名称和地址。</p>

<pre><code>$("#preview").bind("dragstart", function(e){
    e.originalEvent.dataTransfer.setData("DownloadURL", [
        "application/octet-stream", // MIME 类型
        "File.exe",                 // 文件名
        "http://example.com/file.png" // 文件地址
    ].join(":"));
});
</code></pre>

<p>在本书的附加文档资源中可以查看到完整的HTML5拖拽API的例子：assets/ch07/drag.html.</p>

<h3>释放拖拽</h3>

<p>拖拽API允许你监听drop事件，它可以对释放拖拽的文件和其他元素做出响应。现在开始就可以发现拖拽API的曼妙之处了。要想只触发drop事件，你需要撤销两个默认事件dragover和dragenter。例如，用这种方式来撤销这两个事件：</p>

<pre><code>var element = $("#dropzone");

element.bind("dragenter", function(e){
    // 撤销事件
    e.stopPropagation();
    e.preventDefault();
});

element.bind("dragover", function(e){
    // 设置鼠标
    e.originalEvent.dataTransfer.dropEffect = "copy";

    // 撤销事件
    e.stopPropagation();
    e.preventDefault();
});
</code></pre>

<p>你可以在dragover事件中通过设置dropEffect来设置鼠标样式，正如上面代码所示。通过监听dragenter和dragleave事件来添加/删除目标元素的class，可以用这种方式增强拖拽功能的交互性，当用户拖拽的文件进入到目标区域后可以释放拖拽时给他一个提示。</p>

<p>只有当我们撤销掉了dragenter和dragover的事件，才能开始监听drop事件。当拖拽的元素或者文件在目标区域释放时才会触发drop事件。drop事件的dataTransfer对象有一个files属性，它返回拖拽的所有文件的FileList：</p>

<pre><code>element.bind("drop", function(event){
    // 撤销事件
    event.stopPropagation();
    event.preventDefault();

    event = event.originalEvent;

    // 访问拖拽的文件
    var files = event.dataTransfer.files;

    for (var i=0; i &lt; files.length; i++)
    alert("Dropped " + files[i].name);
});
</code></pre>

<p>可以使用dataTransfer.getData()函数来获取文件的数据，将支持的格式作为参数传入。如果那个格式不可用，函数会返回undefined。</p>

<pre><code>var text = event.dataTransfer.getData("Text");
</code></pre>

<p>dataTransfer对象拥有一个只读的type属性，它返回一个包含了由设置在dragstart事件上的媒体类型格式组成的DOMStringList（本质上是数组），此外，如果拖拽了其他的文件，其中一个类型是字符串“Files”。</p>

<pre><code>var dt = event.dataTransfer
for (var i=0; i &lt; dt.types.length; i++)
    console.log( dt.types[i], dt.getData(dt.types[i]) );
</code></pre>

<p>可以在这里看到完整的释放拖拽的示例代码：assets/ch07/drop.html.</p>

<h3>撤销默认的Drag/Drop</h3>

<p>默认情况下，将一个文件拖拽到web页面中会让浏览器重定向到这个文件。我们当然不希望应用的URL地址发生改变，因此需要阻止将文件拖拽进应用的非目标位置时的页面跳转。这很容易实现，只需撤销body的dragover事件即可。</p>

<pre><code>$("body").bind("dragover", function(e){
    e.stopPropagation();
    e.preventDefault();
    return false;
});
</code></pre>

<h2>复制和粘贴</h2>

<p>除了将拖拽功能和桌面作了整合，有些浏览器还支持复制和粘贴。API还没有被标准化，而且没有收纳进HTML5规范中，因此你需要针对不同版本的浏览器决定是否实现复制和粘贴的功能。</p>

<p>有意思的是，IE再一次成为了先行者，从IE5.0时代就开始支持复制和粘贴了。WebKit仿效了微软的API并对它作一定的增强，并和拖拽的API作了整合。两者几乎一模一样，只是使用了不同的对象：复制粘贴使用了clipbordData，拖拽使用了dataTransfer。</p>

<p>Firefox不支持复制粘贴，至少目前不支持，尽管它有一个专有的API可以访问剪切板。WebKit（Safari/Chrome）对复制粘贴支持良好，我认为W3C最终会将剪切板API收纳进标准规范里。浏览器的支持情况如下：</p>

<ul>
<li>Safari >= 6.0</li>
<li>Chrome (only pasting)</li>
<li>Firefox: no support</li>
<li>IE >= 5.0 (different API)</li>
</ul>

<h3>复制</h3>

<p>和复制相关的事件有两个，和剪切相关的事件也有两个：</p>

<ul>
<li>beforecopy</li>
<li>copy</li>
<li>beforecut</li>
<li>cut</li>
</ul>

<p>从事件的名称就可以看到，beforecopy和beforecut是在剪切板操作之前触发的，这样就可以根据需要选择是否撤销复制和剪切的操作。当用户复制了一些选中的文本，这时触发了copy事件，使用clipbordData对象就可以设置自定义的剪切板数据。和dtaTransfer对象类似，clipboardData包含一个setData()方法，参数是媒体格式和字符串值。如果你想调用这个函数，你需要撤销原始的copy事件，阻止默认的浏览器行为（复制操作）。</p>

<p>IE将clipboardData对象设置在window对象上，而不是事件上。你需要检查事件中是否存在这个对象，如果不存在的话再检查一下是否在window对象中。</p>

<p>Firefox实际上可以触发copy事件，但它不允许你访问clipboardData对象。Chrome允许你访问这个对象，但它会忽略你在这个对象上设置的任何数据。</p>

<pre><code>$("textarea").bind("copy", function(event){
    event.stopPropagation();
    event.preventDefault();

    var cd = event.originalEvent.clipboardData;

    // IE
    if ( !cd ) cd = window.clipboardData;

    // Firefox
    if ( !cd ) return;

    cd.setData("text/plain", $(this).text());
});
</code></pre>

<p>根据目前浏览器更新换代的速度，赋值粘贴的API会很快被标准化。如果你想为应用增加复制/粘贴支持，你需要考虑一下实际情况再作决定。</p>

<h3>粘贴</h3>

<p>和粘贴相关的事件有两个，beforepaste和paste。当用户开始粘贴操作但数据还未被粘贴时触发paste事件。同样，不同的浏览器的实现也不一样。Chrome里只有当没有任何元素被选中时才会触发这个事件。IE和Safari都需要有被选中的元素存在。</p>

<p>它的API和drop事件的很像。事件中包含clipboardData属性，可以通过这个对象的getData()方法来获取要粘贴的数据，当然也需要给定媒体格式。不幸的是，根据我的测试结果来看，types属性总是null，所以你无法看到剪切板中的数据支持哪种类型。除非你撤销了这个事件，否则粘贴的操作会照常执行，数据会被粘贴至获得焦点的元素里：</p>

<pre><code>$("textarea").bind("paste", function(event){
    event.stopPropagation();
    event.preventDefault();

    event = event.originalEvent;

    var cd = event.clipboardData;

    // IE
    if ( !cd ) cd = window.clipboardData;

    // Firefox
    if ( !cd ) return;

    $("#result").text(cd.getData("text/plain"));

    // Safari中的事件支持文件的粘贴
    var files = cd.files;
});
</code></pre>

<p>WebKit的“午夜版”（http://nightly.webkit.org/）允许你访问clipboardData的files属性，可以在应用中添加文件粘贴功能。如果这个功能被整理进标准规范中，我希望其他浏览器厂商也及时的实现这个规范。</p>

<p>那么，是否有必要考虑浏览器兼容性情况呢？没错，实际上没有其他更好的变通方法可以实现复制粘贴。比如Cappuccino（http://cappuccino.org/）选择绕过oncopy事件族，通过监听键盘事件来实现。当监听到组合键Ctro+v被按下时，这时它会让一个隐藏的输入框获得焦点，这个输入框可以得到粘贴的数据。它兼容每个浏览器，但显然只支持键盘事件，通过菜单执行的粘贴操作就无法监听到了。</p>

<h2>读文件</h2>

<p>当你获得File的引用时，可以用它来实例化一个FileReader对象将文件内容读入内存。文件的读取是异步的，你需要给FileReader实例提供一个回调函数，当读文件时触发这个回调。</p>

<p>FileReader中包含四个方法来读取文件数据。你根据所需的文件格式来选择合适的方法。</p>

<ul>
<li>readAsBinaryString(Blob|File)：以二进制字符串形式返回这个文件/二进制大对象（BLOB）的数据。每个字节使用0到255之间的整数来表示。</li>
<li>readAsDataURL(Blob|File)：以URL编码的形式返回这个文件/二进制大对象的数据，比如可以把它用作图片的src属性的值。</li>
<li>readAsText(Blob|File, encoding='UTF-8')：以字符串形式返回文件/二进制大对象的数据，默认情况下，字符串以UTF-8格式编码</li>
<li>readAsArrayBuffer(Blob|File)：以ArrayBuffer对象的形式返回文件/二进制大对象的数据，多数浏览器都未实现这个方法。</li>
</ul>

<p>FileReader实例包含很多事件，当其中一个读文件的函数被调用时就触发这些事件。你需要关注的事件包括：</p>

<ul>
<li>onerror：当发生错误时调用</li>
<li>onprogress：当数据在读取过程中，周期性的调用</li>
<li>onload：当数据可用时调用</li>
</ul>

<p>要想使用FileReader，你需要生成一个实例，添加事件监听，使用其中一个读文件的方法。onload事件包含result属性，以正确的格式表示读取的数据：</p>

<pre><code>var reader = new FileReader();
reader.onload = function(e) {
    var data = e.target.result;
};
reader.readAsDataURL(file);
</code></pre>

<p>比如，我们可以将上例中的data属性用作图片源，显示某张图片文件的缩略图：</p>

<pre><code>var preview = $("img#preview")

// 检查文件是否是图片类型
// 并检查它的体积不要太大，否则会造成浏览器的问题
if (file.type.match(/image.*/) &amp;&amp;
        file.size &lt; 50000000) {

    var reader = new FileReader();
    reader.onload = function(e) {
        var data = e.target.result;
        preview.attr("src", data);
    };
    reader.readAsDataURL(file);
}
</code></pre>

<h3>二进制大文件和文件切割</h3>

<p>有时最好将文件的一个片段读入内存，而不是整个文件。HTML5中的文件API提供了一个非常方便的slice()函数。第一个参数是读文件的起始字节位置，第二个参数是以字节为单位的偏移量（或片段长度）。它返回Blob对象，我们可以使用支持File对象（比如FileReader）的方法对它做操作。比如，我们可以用这种方法将文件读入缓存里：</p>

<pre><code>var bufferSize = 1024;
var pos = 0;

var onload = function(e){
    console.log("Read: ", e.target.result);
};

var onerror = function(e){
    console.log("Error!", e);
};

while (pos &lt; file.size) {
    var blob = file.slice(pos, bufferSize);

    var reader = new FileReader();
    reader.onload = onload;
    reader.onerror = onerror;
    reader.readAsText(blob);
    pos += bufferSize;
}
</code></pre>

<p>正如你所看到的，你可以使用FileReader实例一次，之后你需要生成一个新的实例。</p>

<p>你可以在这里看到完整的示例代码：assets/ch07/slices.html。有一点需要特别注意，如果沙箱【译注：一个html文件的打开方式有很多种，可以直接将这个文件拖入浏览器来访问，也可以放入虚拟主机中通过http协议来访问，这里所说的“沙箱“即特指打开这个文件的方式】是本地的那么就无法读文件，换句话说，如果直接从硬盘读取slices.html，而不是通过域名来访问它，读文件操作会失败并触发一个onerror事件。</p>

<h2>自定义浏览器按钮</h2>

<p>在开发项目的过程中，经常会遇到用程序打开文件预览窗口。换句话说，我们往往希望点击一个带自定义样式的“浏览“或”附件“按钮来即刻打开浏览文件对话框，这样就不必忍受浏览器自带的（丑陋无比的）按钮传统样式了。但从安全角度来看，这更像是一种“奇技淫巧”。文件输入框并不提供打开浏览文件对话框的函数，而且Firefox的实现更诡异，当点击文件输入框时甚至无法触发自定义的click事件。</p>

<p>当前的解决办法听起来像是一种hack技术，但的确很好用。当将鼠标移动到按钮上方时，在相同的位置放置一个透明的文件输入框，尺寸和按钮一样。透明的文件输入框可以获取任何点击事件，并打开一个浏览文件的对话框。</p>

<p>在本书附加文件的assets/ch07文件夹里，你可以找到jquery.browse.js，这个文件是基于jQuery的一个插件实现了这种功能。调用jQuery实例的browseElement()函数来创建一个自定义的浏览按钮。这个函数将返回一个文件输入框，可以给它绑定change事件监听，检测用户何时选中了一些文件。</p>

<pre><code>var input = $("#attach").browseElement();

input.change(function(){
    var files = $(this).attr("files");
});
</code></pre>

<p>这个插件兼容各个浏览器，使用起来非常方便！</p>

<h2>上传文件</h2>

<p>在XMLHttpRequest Level 2规范（http://www.w3.org/TR/XMLHttpRequest2/）赋予了Ajax上传文件的能力。之前文件上传的用户体验简直糟糕透了。一旦选择上传一个文件页面就会重新加载，用户必须等待文件上传完毕，没有任何上传进度提示让用户体验很不好，更谈不上易用性了。幸运的是，XHR 2解决了这个问题。它允许我们在后台上传文件，甚至提供了上传事件，这样就可以实时的监控文件的上传进度了。主流浏览器都支持这种做法：</p>

<ul>
<li>Safari >= 5.0</li>
<li>Firefox >= 4.0</li>
<li>Chrome >= 7.0</li>
<li>IE: no support</li>
<li>Opera: no support</li>
</ul>

<p>可以使用现有的XMLHttpRequest API来完成文件上传，使用send()函数即可，或者使用FormData实例。FormData实例用一种非常简单的接口表示了表单的内容。可以直接通过抓取一个表单来创建FormData，或者在实例化对象时传入已经存在的form元素：</p>

<pre><code>var formData = new FormData($("form")[0]);

// 可以添加字符串
formData.append("stringKey", "stringData");

// 甚至可以添加文件对象
formData.append("fileKey", file);
</code></pre>

<p>当formData中的数据准备完成，就可以使用XMLHttpRequest将数据POST到服务器了。如果你在使用jQuery来处理Ajax请求，则需要将processData选项置为false，这样jQuery就不会尝试去对数据作序列化处理了。不要设置Content-Type头，因为浏览器会自动将请求头设置为multipart/form-data，同时设置的还有多个字段的边界：</p>

<pre><code>jQuery.ajax({
    data: formData,
    processData: false,
    url: "http://example.com",
    type: "POST"
})
</code></pre>

<p>除了FormData之外还有另一种方法，将文件直接传给XHR对象的send()函数：</p>

<pre><code>var req = new XMLHttpRequest();
req.open("POST", "http://example.com", true);
req.send(file);
</code></pre>

<p>或者使用jQuery的Ajax API可以这样实现：</p>

<pre><code>$.ajax({
    url: "http://example.com",
    type: "POST",
    success: function(){ /* ... */ },
    processData: false,
    data: file
});
</code></pre>

<p>这种方式和传统的multipart/form-data方式有很小的不同，可以忽略。通常我们会将文件信息（比如文件名）也上传上去。但这个例子中并不是这样，这里上传的只是纯文件内容。要想将文件的信息也一并传入，可以设置自定义的头，比如X-File-Name。我们的服务器可以读取这些头字段，并正确处理这些信息：</p>

<pre><code>$.ajax({
    url: "http://example.com",
    type: "POST",
    success: function(){ /* ... */ },
    processData: false,
    contentType: "multipart/form-data",

    beforeSend: function(xhr, settings){
        xhr.setRequestHeader("Cache-Control", "no-cache");
        xhr.setRequestHeader("X-File-Name", file.fileName);
        xhr.setRequestHeader("X-File-Size", file.fileSize);
    },
    data: file
});
</code></pre>

<p>不幸的是，很多服务器处理上传文件时都遇到不小麻烦。相比于multipart或从参数中读取URL编码的数据来说，纯文件数据更难处理。使用这种方法就需要你自己对请求作解析。正是因为这个原因，我推荐使用FormData对象，以 multipart/form-data格式发送序列化后的上传数据。在assets/ch07文件夹中可以找到jquery.upload.js，它是一个jQuery插件，它将文件上传的功能封装成了一个简单的接口：$.upload(url, file)。</p>

<h3>Ajax进度条</h3>

<p>XHR 2 规范加入了对progress事件的支持，下载和上传都支持这个事件。使用它就可以实现实时的文件上传进度条，可以让用户时刻跟踪上传进度。</p>

<p>想要监听下载请求的progress事件，只需直接给XHR实例绑定事件即可：</p>

<pre><code>var req = new XMLHttpRequest();

req.addEventListener("progress", updateProgress, false);
req.addEventListener("load", transferComplete, false);
req.open();
</code></pre>

<p>对于上传progress事件来说，则需要给XHR实例的upload属性添加监听：</p>

<pre><code>var req = new XMLHttpRequest();

req.upload.addEventListener("progress", updateProgress, false);
req.upload.addEventListener("load", transferComplete, false);
req.open();
</code></pre>

<p>load事件只有在请求完成时才会触发，但是会在服务器终结响应之前触发。我们可以将它添加至jQuery，因为XHR对象和设置都被传给了beforeSend回调。来看一个完整的例子，包括自定义的头：</p>

<pre><code>$.ajax({
    url: "http://example.com",
    type: "POST",
    success: function(){ /* ... */ },
    processData: false,
    dataType: "multipart/form-data",

    beforeSend: function(xhr, settings){
        var upload = xhr.upload;

        if (settings.progress)
            upload.addEventListener("progress", settings.progress, false);

        if (settings.load)
            upload.addEventListener("load", settings.load, false);

        var fd = new FormData;

        for (var key in settings.data)

            fd.append(key, settings.data[key]);
        settings.data = fd;
    },

    data: file
});
</code></pre>

<p>progress事件包含上传的position（已经上传的字节数）和total（上传的总字节数）。你可以使用这两个属性来计算进度的百分比：</p>

<pre><code>var progress = function(event){
    var percentage = Math.round((event.position / event.total) * 100);
    // 设置进度条
}
</code></pre>

<p>实际上这个事件还包含一个时间戳，因此如果你记录了开始上传的时间，可以计算出离上传完成还需多长时间（ETA）：</p>

<pre><code>var startStamp = new Date();
var progress = function(e){
    var lapsed = startStamp - e.timeStamp;
    var eta = lapsed * e.total / e.position - lapsed;
};
</code></pre>

<p>如果上传文件体积很小时，这个估计完成时间会非常不准（当然也很快）。在我看来，如果文件体积很大上传时间超过大约四分钟的话，最好给出ETA。多数情况下只需进度条就够了，这也能清晰的告知用户大概还需要多久能上传完毕。</p>

<h2>jQuery拖拽上传</h2>

<p>现在，让我们把学到的东西应用到实践中，我们来实现一个可拖拽上传文件的功能。我们需要几个库：jquery.js用来作底层库，jquery.ui.js用来构建进度条，jquery.drop.js用来提供抽象的拖拽API，以及jquery.upload.js用来作Ajax上传。我们所有的逻辑都将放在jQuery.ready()中，因此程序会在DOM树构建完成后运行：</p>

<pre><code>//= require &lt;jquery&gt;
//= require &lt;jquery.ui&gt;
//= require &lt;jquery.drop&gt;
//= require &lt;jquery.upload&gt;
jQuery.ready(function($){
    /* ... */
});
</code></pre>

<h3>创建拖拽目标区域</h3>

<p>我们想把文件拖拽到#drop元素上，首先要把它转换为释放拖拽的区域。这就需要绑定drop事件，撤销事件并遍历释放拖拽的文件列表，然后将它们传入uploadFile()函数：</p>

<pre><code>var view = $("#drop");
view.dropArea();

view.bind("drop", function(e){
    e.stopPropagation();
    e.preventDefault();

    var files = e.originalEvent.dataTransfer.files;
    for ( var i = 0; i &lt; files.length; i++)
        uploadFile(files[i]);

    return false;
});
</code></pre>

<h3>上传文件</h3>

<p>现在来看uploadFile()函数，“让我们见证奇迹发生的时刻！“ 我们使用jquery.upload.js中的$.upload()函数来发送Ajax上传请求到服务器。然后监听请求的上传进度事件并更新jQuery UI 进度条。当上传完成时，我们即刻通知用户上传已经完成，并将元素删除掉。</p>

<pre><code>var uploadFile = function(file){
    var element = $("&lt;div /&gt;");
    element.text(file.fileName);

    var bar = $("&lt;div /&gt;");
    element.append(bar);
    $("#progress").append(element);

    var onProgress = function(e){
        var per = Math.round((e.position / e.total) * 100);
        bar.progressbar({value: per});
    };

    var onSuccess = function(){
        element.text("Complete");
        element.delay(1000).fade();
    };

    $.upload("/uploads", file, {upload: {progress: onProgress}, success: onSuccess});
};
</code></pre>

<p>怎么样，简单吧！可以在这里查看到完整的示例代码：assets/ch07/dragdro-pupload.html</p>
</div>
</body>
</html>