<style>
p img {
        float:none;
}
</style>
# 第1章  MVC和类

## 之初

JavaScript程序开发已经和最初我们想象中的模样有了天壤之别，也很少有人能记起从JavaScript诞生之初的Nectscape浏览器到如今异常强大的解析引擎——比如Google的V8——的进化历程。JavaScript到ECMAScript的标准化道路也充满坎坷。然而对于JavaScript的发明者来说，做梦也不会想到JavaScript会有今天这么强大。

尽管JavaScript已然非常成功和流行，但仍然被大多数人所误解。只有少数人知道JavaScript是一种强大的、动态的面向对象编程语言。JavaScirpt中诸如原型继承、模块和命名空间等高级特性依然会让很多人感到吃惊。那么，为什么这门语言会如此被误解？

一个原因是早期的JavaScirpt实现非常糟糕，有很多bug，另一个原因是这个名字带有“Java”前缀，让人以为它和Java有关系。实际上它和Java是完全不同的两种语言。然而在我看来，真正原因在于大多数开发者接触使用JavaScript的方式。对于其他语言来说，比如Python和Ruby，开发者必须要坚持阅读技术文档、视频教程和学习指南。直到现在，使用JavaScript开发程序也不用这样，开发者的需求往往是给现有代码添加一个表单验证、弹出框或图片轮播控件，而且工期也很紧。因此他们直接去网上找一段能用的代码就可以了，而不必花时间去学习理解这门语言。很多人就是这样开始接触JavaScript的，并堂而皇之的把JavaScirpt技能写入他们的简历。

现在，JavaScript引擎和浏览器已经变的非常强大，使用JavaScript来构建庞大的应用已经屡见不鲜，而且越来越流行。像Gmail和Goolge Maps之类的产品给我们带来了web应用全新的体验，开发者们顿时趋之若鹜。公司开始雇用全职的JavaScript程序员。JavaScript也早已不再是只能完成表单验证的“不入流的脚本语言”了。现在凭借其自身独特的优势，JavaScript已经成为一门独立的、潜力无穷的编程语言。

这种趋势说明JavaScript应用会如雨后春笋一般遍地开花。不幸的是，可能是因为JavaScript糟糕的过去，很多新构建的应用是非常脆弱的。由于某些原因，当使用JavaScript开发应用时，那些经典的设计模式和最佳实践却被抛在了脑后。开发者往往忽略架构模型，比如MVC模型，他们常将应用中的HTML和JavaScript混杂在一起，远看像一个大杂烩。

这本书不会教给你JavaScript是一门什么样的语言，你可以阅读其他的书来学习使用JavaScript，比如 Douglas Crockford的“JavaScript 语言精萃”。但是，本书将会向你展示如何搭建复杂的JavaScript应用，教你创造不可思议的用户体验。

## 增加结构

构建大型的JavaScript应用的秘诀是不要构建大型JavaScript应用。相反，你应当把你的应用解偶成一系列相互平等且独立的部分。开发者常犯的错误是创建应用时使用了很多依赖，用了很多JavaScript文件，并在HTML页面中用大量的script标签来引入这些文件。这类应用非常难于维护和扩展，因此无论如何都应当避免这种情况的发生。

开始构建你的应用的时候，花点精力来做应用的架构，这会为最终结果带来意想不到的改观。不管你之前怎么看待JavaScript，从现在开始就应当将JavaScript当作一门面向对象的编程语言来对待。如果你使用Python和Ruby这样的编程语言来开发应用，你同样会使用类、继承、对象和设计模式等。对于构建服务器端应用来说，体系结构是非常重要的，那么，为什么不在客户端app中应用这些东西呢？

本书提倡使用MVC模式，这是一种久经考验的搭建应用的方式，可以确保应用的可维护性和可扩展性。MVC模式完全可以应用于JavaScript应用里。

## 什么是MVC？

MVC是一种设计模式，它将应用划分为三个部分：数据（模型）、展现层（视图）和用户交互层（控制器），换句话说，一个事件的发生是这样的过程：

1. 用户和应用产生交互
2. 控制器的事件处理器被触发
3. 控制器从模型中请求数据，并将其交给视图
4. 视图将数据呈现给用户

现在来看一个具体的例子，图1-1展示了在Holla中如何发送新的聊天消息。

![png](http://img01.taobaocdn.com/tps/i1/T1zQOvXe0UXXXXXXXX-833-176.jpg)

图1-1，从Holla中发送一个新的聊天消息

1. 用户提交一个新的聊天消息
2. 控制器的事件处理器被触发
3. 控制器创建了一个新的聊天模型（Chat Model）记录
4. 控制器然后更新视图
5. 用户在聊天窗口看到新的聊天消息

我们可以不用类库或框架就能实现这种MVC架构模型。关键是要将MVC的每块按照职责进行划分，将代码清晰的分割为若干部分，并保持良好的解偶。这样可以对每个部分进行独立开发、测试和维护。

下面来详细讲解MVC中的各个组成部分。

### 模型

模型用来存放应用的所有数据对象。比如，有一个User模型，用以存放用户列表、他们的属性以及所有与模型有关的逻辑。

模型不必知晓视图和控制器的细节。模型只需包含数据以及直接和这些数据相关的逻辑。任何事件处理逻辑、视图模板、以及那些和模型无关的代码都应当隔离在模型之外。将模型和视图的代码混在一起是违反MVC架构的原则的。模型是最应该从你的应用当中解偶出来的部分。

当控制器从服务器抓取数据或创建新的记录时，它就将数据包装成模型实例。也就是说，我们的数据是面向对象的（object oriented），任何定义在这个数据模型里的函数或逻辑都可以直接调用。

因此，不要这样做：

	var user = users["foo"];
	destroyUser(user);

而要这样作：

	var user = User.find("foo");
	user.destroy();

第一段代码没有命名空间的概念，并且不是面向对象的。如果在应用中定义了另一个destoryUser()函数的话，就会和之前的函数产生冲突。我们应当确保全局变量和函数的个数尽可能的少。在第二段代码中，destory()函数是存放在命名空间User的实例中的，User中存放了所有的记录。当然这只是理想状况，因为我们控制了全局变量的个数，更好的避免了潜在的冲突，这种代码更加清晰，而且非常容易做继承，类似destory()这种函数就不用在每个模型中都定义一遍了。

在第3章中我们会更深入的讲解模型，其中包括从服务器下载数据以及创建对象关系映射（ORM）。

### 视图

视图层是呈现给用户的，用户与之产生交互。在JavaScript应用当中，视图大都是由HTML、CSS和JavaScript模板组成的。除了模板中简单的条件语句之外，视图不应当包含任何其他逻辑。

实际上，和模型类似，视图也应当从应用的其他部分中解偶出来。视图不必知晓模型和控制器中的细节，它们是相互独立的。将逻辑混入视图之中是编程的大忌。

这并不是说MVC不允许包含视觉呈现相关的逻辑，只要这部分逻辑没有定义在视图之内即可。我们将视觉呈现逻辑归类为“视图助手”（helper）：和视图有关的独立的小型工具函数。

来看下面的例子，视图中包含了逻辑，这是一个反例，平时不应当这样做：

	// template.html
	<div>
		<script>
			function formatDate(date) {
				/* ... */
			};
		</script>
		${ formatDate(this.date) }
	</div>

在这段代码中，我们把formatDate()函数直接插入视图中，这违反了MVC的原则，结果导致标签看上去像大杂烩一样不可维护。可以将视觉呈现逻辑剥离出来，放入视图助手中，正如下面的代码就避免了这个问题，可以让这个应用的结构满足MVC。

	// helper.js
	var helper = {};
	helper.formatDate = function(){ /* ... */ };

	// template.html
	<div>
	   ${ helper.formatDate(this.date) }
	</div>

此外，所有视觉呈现逻辑都包含在helper变量中，这是一个命名空间，可以防止潜在的冲突并保持代码清晰、可扩展。

不要太在意视图和模板的细节，我们会在第5章中有详细讲述。本小节的目的只是简单介绍视图和MVC架构模式之间的联系。

### 控制器

控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行处理（很可能包含模型），并相应的更新视图。当页面加载时，控制器会给视图添加事件监听，比如监听表单提交或按钮点击。然后，当用户和你的应用产生交互时，控制器中的事件触发器就开始工作了。

不用使用类库和框架也能实现控制器，下面这个例子就是使用简单的jQuery代码来实现的：

	var Controller = {};
	// 使用匿名函数来封装一个作用域
	(Controller.users = function($){

	   var nameClick = function(){
	   /* ... */
	   };

	   // 在页面加载时绑定事件监听
	   $(function(){
		   $("#view .name").click(nameClick);
	   });
	})(jQuery);

我们创建了user控制器，这个控制器是放在Controller命名空间下的。然后，我们使用了一个匿名函数封装了一个作用域，以避免对全局作用域造成污染。当页面加载时，程序给视图元素绑定了点击事件的监听。

正如你所看到的，控制器并不依赖类库或框架。然而，为了构建一个完整的MVC框架，我们需要将模型从视图中抽离出来。控制器和状态的详细内容会在第4章详细讲解。

## 向模块化进军，创建类

在讲解MVC的本质之前，我们首先给大家补习一下基础知识，比如JavaScript的类和事件，只有打下一个坚实的基础才能更好的学习理解更高级的概念。

对于静态的类来说，JavaScript对象直接量就已经够用了。但使用继承和实例来创建经典的类往往更有帮助。有必要强调一下：JavaScript是基于原型的编程语言，并没有内置类的实现。但通过JavaScript可以轻易的模拟出经典的类。

JavaScript中的类口碑并不太好，因为“不够JavaScript”而饱受批评。jQuery并没有涉及太多架构方法和继承模式，这让JavaScript开发者确信他们也不必考虑太多架构性的东西，甚至觉得类的用处不大或干脆禁用类。实际上，类是另一种有用的工具，作为一名实用主义者，我相信类在JavaScript中的重要性丝毫不亚于它在其他现代编程语言中的重要性。

JavaScript中并没有真正的类，但JavaScript中有构造函数和new运算符。构造函数用来给实例对象初始化属性和值。任何JavaScript函数都可以用作构造函数，构造函数必须使用new运算符作为前缀，构造函数可以创建新的实例。

new运算符改变了函数的执行上下文，同时改变了return语句的行为。实际上，它和传统的实现了类的语言中的使用方法是很类似的：

	var Person = function(name) {
		this.name = name;
	};

	// 实例化一个Person
	var alice = new Person('alice');

	// 检查这个实例
	assert( alice instanceof Person );

构造函数的命名通常使用驼峰命名法，首字母大写，以此和普通的函数区分开来。这是一种习惯用法。记住这一点非常重要，因为你不希望用省略new的方式来调用构造函数。

	// 不要这么作!
	Person('bob'); //=> undefined

这个函数只会返回undefined，并且执行上下文是window（全局对象），你无意间创建了一个全局变量name。调用构造函数时不要丢掉new。

当使用new关键字来调用构造函数时，执行上下文从全局对象（window）变成一个空的上下文，这个上下文代表了新生成的实例。因此，this关键字指向当前创建的实例。尽管理解起来有些绕，实际上其他语言内置类机制的实现也是如此。

默认情况下，如果你的构造函数中没有返回任何内容，就会返回this——当前的上下文。要不然就返回任意非原始类型的值。比如，我们可以返回一个用以初始化一个新的类的函数，第一步要做的是创建模拟类的基础代码。

 
	var Class = function(){
	   var klass = function(){
		   this.init.apply(this, arguments);
	   };
	   klass.prototype.init = function(){};
	   return klass;
	};

	var Person = new Class;

	Person.prototype.init = function(){
	   // 基于Person的实例做初始化
	};

	// 用法:
	var person = new Person;

令人费解的是，由于 JavaScript 2 规范从未被实现过，class一直都是保留字，最常见的做法是将变量名class改为`_class`或`klass`。


## 给类添加函数

在JavaScript中，在构造函数中给类添加函数和给对象添加属性是一模一样的：

	Person.find = function(id){ /*...*/ };
	var person = Person.find(1);

要想给构造函数添加实例方法，则需要用到构造函数的prototype：

	Person.prototype.breath = function(){ /*...*/ };

	var person = new Person;
	person.breath();

一种常用的模式是给类的prototype起一个别名fn，写起来也更简单：

	Person.fn = Person.prototype;

	Person.fn.run = function(){ /*...*/ };

实际上这种模式在jQuery的插件开发中是很常见的，将函数添加至jQuery.fn中也就相当于添加至jQuery的原型中。

## 给“类”库添加方法

现在，我们的“类”库（class library）【译注：原文中此处和小标题中都是class library，意思是“实现了类机制的类库”，直译为“类库”，有时library也译为类库，但两者的含义是不一样的，读者应能自行分辨】包含了生成一个实例并初始化这个实例的逻辑，给类添加属性和给构造函数添加属性是一样的。

直接给类设置属性和设置其静态成员是等价的：

	var Person = new Class;

	// 直接给类添加静态方法
	Person.find = function(id){ /* ... */ };

	// 这样我们可以直接调用它
	var person = Person.find(1);

给类的原型设置的属性在类的实例中也是可用的：

	var Person = new Class;

	// 在原型中定义函数
	Person.prototype.save = function(){ /* ... */ };

	// 这样就可以在实例中调用它
	var person = new Person;
	person.save();

但在我看来这种写法有些绕，不切实际而且不够简洁。很难一眼就分辨出类的静态属性和实例的属性。因此我们采用另外一种不同的方法来给类添加属性，这里用到了两个函数，extend()和include()：

	var Class = function () {
	   var klass = function () {
		   this.init.apply(this, arguments);
		};

	   klass.prototype.init = function () {};

	   // 定义 prototype 的别名
	   klass.fn = klass.prototype;

	   // 定义类的别名
	   klass.fn.parent = klass;

	   // 给类添加属性
	   klass.extend = function (obj) {
		   var extended = obj.extended;
		   for (var i in obj) {
		       klass[i] = obj[i];
		   }
		   if (extended) extended(klass)
	   };

	   // 给实例添加属性
	   klass.include = function (obj) {
		   var included = obj.included;
		   for (var i in obj) {
		       klass.fn[i] = obj[i];
		   }
		   if (included) included(klass)
	   };
	   return klass;
	};

这段代码是“类”库的增强版，我们使用extend()函数来创建一个类，这个函数的参数是一个对象。通过迭代将对象的属性直接拷贝到类上：

	var Person = new Class;

	Person.extend({
	   find:function(id) { /* ... */ },
	   exists: functions(id) { /* ... */ }
	});

	var person = Person.find(1);

include()函数的工作原理也是一样的，只不过不是将属性拷贝至类中，而是拷贝至类的原型中。换句话说，这里的属性是类实例的属性，而不是类的静态属性。

	var Person = new Class;

	Person.include({
	   save:function(id) { /* ... */ },
	   destroy: functions(id) { /* ... */ }
	});

	var person = new Person;
	person.save();

同样，这里的实现支持extended和included回调。将属性传入对象后就会触发这两个回调：

	Person.extend({
	   extended: function(klass) {
		   console.log(klass, " was extended!");
	   }
	});

如果你基于Ruby实现过类，会感觉它的写法与此很相近。这种写法之美在于它已经可以支持模块了。模块是可重用的代码段，用这种方法可以实现各种继承，用来在类之间共享通用的属性。
 
	var ORMModule = {
	   save: function(){
		   // 共享的函数
	   }
	};

	var Person = new Class;
	var Asset = new Class;

	Person.include(ORMModule);
	Asset.include(ORMModule);

## 基于原型的类继承

我们之前已经提到过prototype属性很多次了，但还没有正儿八经的解释过它。现在我们来详细讲解什么是原型，以及如何用它来实现类的继承。

JavaScript是基于原型的编程语言，原型用来区别类和实例，这里提到一个概念：原型对象（prototypical object）。原型是一个“模板”对象，它上面的属性被用作初始化一个新对象。任何对象都可以作为另一个对象的原型对象，以此来共享属性。实际上可以将其理解为某种形式的继承。

当你读取一个对象的属性时，JavaScript首先会在本地对象中查找这个属性，如果没有找到，JavaScript开始在对象的原型中查找，若还未找到还会继续查找原型的原型，直到查找到Object.prototype。如果找到这个属性，则返回这个属性，否则返回undefined。

换句话说，如果你给Array.prototype添加了属性，那么所有的JavaScript数组都具有了这些属性。

为了让子类继承父类的属性，首先需要定义一个构造函数，然后，你需要将父类的新实例赋值给构造函数的原型。代码如下：
 
	var Animal = function(){};

	Animal.prototype.breath = function(){
	   console.log('breath');
	};

	var Dog = function(){};

	// Dog继承了Animal
	Dog.prototype = new Animal;

	Dog.prototype.wag = function(){
	   console.log('wag tail');
	};

现在我们来检查一下继承是否生效了：
 
	var dog = new Dog;
	dog.wag();
	dog.breath(); // 继承的属性


## 给“类”库添加继承

现在来给我们的“类”库添加继承，我们通过传入一个可选的父类来创建新类：
 
	var Class = function(parent){
	   var klass = function(){
		   this.init.apply(this, arguments);
	   };

	   // 改变klass的原型
	   if (parent) {
		   var subclass = function() { };
		   subclass.prototype = parent.prototype;
		   klass.prototype = new subclass;
	   };

	   klass.prototype.init = function(){};

	   // 定义别名
	   klass.fn = klass.prototype;
	   klass.fn.parent = klass;
	   klass._super = klass.__proto__;

	   /* include/extend 相关的代码... */

	   return klass;
	};

如果将parent传入Class构造函数，那么所有的子类则必然共享同一个原型。这种创建临时匿名函数的小技巧避免了在继承的时候创建实例，这里暗示了只有实例的属性才会被继承，而非类的属性。设置对象的`“__proto__”`属性并不是所有浏览器都支持，类似Super.js的类库则通过属性拷贝的方式来解决这个问题，而非通过固有的动态继承的方式来实现。

现在，我们可以通过给Class传入一个父类来实现一个简单的继承：

	var Animal = new Class;

	Animal.include({
	   breath: function(){
		   console.log('breath');
	   }
	});

	var Cat = new Class(Animal)

	// 用法
	var tommy = new Cat;
	tommy.breath();

## 函数调用

在JavaScript中，函数和其他东西一样都是对象。然而，和其他对象不同的是，函数是可调用的。函数内上下文this的取值取决调用它的位置和方法。

除了使用方括号可以调用函数之外，还有其他两种方法可以调用函数：apply()和call()。两者的区别在于传入函数的参数的形式。

apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。例如：

	function.apply(this, [1, 2, 3])

call()函数的行为和apply()并无不同，只是使用方法不一样。call()的第一个参数是上下文，后续是实际传入的参数序列，换句话说，这里使用多参数——而不是类似apply()的数组——来将参数传入函数。

	function.call(this, 1, 2, 3);

为什么要更换上下文？这的确是一个问题，因为其他编程语言并不允许手动更换上下文也没什么大碍。JavaScript中允许更换上下文是为了共享状态，尤其是在事件回调中。（依个人只见，这是语言设计的一个错误，因为这会对初学者造成一些困扰，并引入一些bug，但亡羊补牢为时已晚，你需要花精力来弄清楚call和apply如何工作的）

jQuery在其API的实现中就利用了apply()和call()来更改上下文，比如在事件处理程序中或者使用each()来作遍历时。起初这很让人费解，一旦你理解了它你就会发先它非常有用：

	$('.clicky').click(function(){
	   // ’this’指向当前节点
	   $(this).hide();
	});

	$('p').each(function(){
	   // 'this'指向本次迭代
	   $(this).remove();
	});

为了访问原始上下文，可以将this的值存入一个局部变量中，这是一种常见的模式，比如：

	var clicky = {
	   wasClicked: function(){
	   /* ... */
	   },
	   addListeners: function(){
		   var self = this;
		   $('.clicky').click(function(){
		       self.wasClicked()
		   });
	   }
	};

	clicky.addListeners();

然而我们可以使用apply来将这段代码变得更干净一些，通过将回调包装在另外一个匿名函数中，来保持原始的上下文。

	var proxy = function(func, thisObject){
	   return(function(){
		   return func.apply(thisObject, arguments);
	   });
	};

	var clicky = {
	   wasClicked: function(){
		   /* ... */
	   },
	   addListeners: function(){
		   var self = this;
		   $('.clicky').click(proxy(this.wasClicked, this));
	   }
	};

因此在上面的例子中，我们在点击事件的回调中指定了要使用的上下文；jQuery中调用这个函数所用的上下文就可以省略掉了。实际上，jQuery也包含了实现了这个功能的API，你或许已经猜到了，jQuery.proxy()：

	$('.clicky').click($.proxy(function(){ /* ... */ }, this));

使用apply()和call()还有其他很有用的原因，比如“委托”。我们可以将一个调用委托给另一个调用，甚至可以修改传入的参数：

	var App {
	   log: function(){
		   if (typeof console == "undefined") return;

		   // 将参数转换为合适的数组
		   var args = jQuery.makeArray(arguments);

		   // 插入一个新的参数
		   args.unshift("(App)");

		   // 委托给console
		   console.log.apply(console, args);
	   }
	};

在这里例子中首先构建了参数数组，然后将我们自己的参数添加进去，最后将这个调用委托给了console.log()。你可能对arguments变量不熟悉，arguments是解释器内置的当前调用的作用域内用来保存参数的数组。但它并不是真正的数组，比如它是不可变的，因此我们需要通过jQuery.makeArray()将其转换为可用的数组。


## 控制“类”库的作用域

上文提到的proxy函数是一个非常有用的模式，我们应当将其添加至我们的“类”库中。我们在类和实例中都添加proxy函数，这样就可以在事件处理程序之外的地方处理函数的时候和下面这段代码所示的场景中保持类的作用域

	var Class = function(parent){
	   var klass = function(){
		   this.init.apply(this, arguments);
	   };

	   klass.prototype.init = function(){};
	   klass.fn = klass.prototype;

	   // 添加一个proxy函数
	   klass.proxy = function(func){
		   var self = this;
		   return(function(){
		       return func.apply(self, arguments);
		   });
	   }

	   // 在实例中也添加这个函数
	   klass.fn.proxy = klass.proxy;
	   return klass;
	};

现在我们可以使用proxy()函数来包装函数，以确保它们在正确的作用域中被调用：

	var Button = new Class;
	Button.include({
	   init: function(element){
		   this.element = jQuery(element);

		   // 代理了这个click函数
		   this.element.click(this.proxy(this.click));
	   },

	   click: function(){ /* ... */ }
	});

如果我们没有使用proxy将click()的回调包装起来，它就会基于上下文this.element来调用，而不是Button，这会造成各种问题。在新版本的JavaScript——ECMAScript 5（ES5）——中同样加入了bind()函数，用以控制调用的作用域。bind()是基于函数进行调用的，用来保函数是在指定的this值所在的上下文中调用的。
 
	Button.include({
	   init: function(element){
		   this.element = jQuery(element);

		   // 绑定这个click函数
		   this.element.click(this.click.bind(this));
	   },
	   click: function(){ /* ... */ }
	});

这个例子和我们的proxy()函数是等价的，它能确保click()函数基于正确的上下文进行调用。但老版本的浏览器不支持bind()，幸运的是，如果需要的话可以很容易的手动实现它。对于老版本的浏览器来说，手动实现的bind()兼容性也不错，通过直接扩展相关对象的原型，这样就可以像今天在ES5中使用bind()那样在任意浏览器中调用它，例如，下面就是一段实现了bind()函数的代码：

	if (!Function.prototype.bind) {
	   Function.prototype.bind = function (obj) {
		   var slice = [].slice,
		       args = slice.call(arguments, 1),
		       self = this,
		       nop = function () {},
		       bound = function () {
		       return self.apply(this instanceof nop ? this : (obj || {}),
		                           args.concat(slice.call(arguments)));
		       };

		   nop.prototype = self.prototype;

		   bound.prototype = new nop();

		   return bound;
	   };
	}

如果浏览器原生不支持bind()，我们仅仅重写了Function的原型。现代浏览器则可以继续使用内置的实现。对于数组来说这种“打补丁”【译注：原文为Shimming，意指“补偿”】式的做法非常有用，因为在新版本的JavaScript中，数组增加了很多新的特性。我个人推荐使用es5-shim（http://goo.gl/bbzdE）项目，因为它涵盖了ES5中新增的大部分特性。

## 添加私有方法

迄今为止，我们为“类”库添加的属性都是“公开的”，可以被随时修改。现在我们来探究一下如何给“类”添加私有属性。

很多开发者都习惯在私有属性之前冠以下划线前缀（`_`）。尽管本质上这并不是私有属性，但至少能一眼看出它就是私有属性，因此它是私有API的组成部分。我尽可能的不考虑这种情况，因为它看上去实在太丑陋了。

JavaScript的确支持不可变属性，然而在主流浏览器中并未实现，我们还没办法直接利用这个特性。相反，我们可以利用JavaScript匿名函数来创建私有作用域，这些私有作用域只能在内部访问：

	var Person = function(){};

	(function(){

	   var findById = function(){ /* ... */ };

	   Person.find = function(id){
		   if (typeof id == "integer")
		       return findById(id);
	   };

	})();

我们将类的属性都包装进一个匿名函数中，然后创建了局部变量（findById），这些局部变量只能在当前作用域中被访问到。Person变量是在全局作用域中定义的，因此可以在任何地方都能访问到。

定义变量的时候不要丢掉var运算符，因为如果丢掉var就会创建全局变量。如果你需要定义全局变量，在全局作用域中定义它或者定义为window的属性：

	(function(exports){
	   var foo = "bar";
	   
		// 将变量暴露出去
	   exports.foo = foo;
	})(window);

	assertEqual(foo, "bar");

## “类”库

为了便于理解本书中的很多概念，最好先理解“类”的一些基础理论，但实际上开发人员往往是直接使用一个类库。jQuery本身并不支持类，但通过插件的方式可以轻易引入类的支持，比如HJS(http://goo.gl/nGYqR)，HJS允许你通过给$.Class.create传入一组属性来定义类：

	var Person = $.Class.create({
	   // 初始化函数
	   initialize: function(name) {
		   this.name = name;
	   }
	});

可以在创建类的时候传入父类，这样就实现了类的继承：

	var Student = $.Class.create(Person, {
	   price: function() { /* ... */ }
	});

	var alex = new Student("Alex");
	alex.pay();

可以直接给类挂载属性：

	Person.find = function(id){ /* ... */ };

HJS的API中同样包含一些工具函数，比如clone()和equal()：

	var alex = new Student("Alex");
	var bill = alex.clone();

	assert( alex.equal(bill) );

HJS并不是我们的唯一选择，Spine（http://goo.gl/8kN8O）同样实现了类，通过直接在页面中引入spine.js来使用它：

	<script src="http://maccman.github.com/spine/spine.js"> </script>
	<script>
	   var Person = Spine.Class.create();

	   Person.extend({
		   find: function() { /* ... */ }
	   });

	   Person.include({
		   init: function(atts){
		       this.attributes = atts || {};
		   }
	   });

	   var person = Person.init();
	</script>

Spine“类”库的API和我们本章所构建的“类”库API非常类似。使用extend()来添加类属性，使用include()来添加实例属性。通过给Spine.Class传入父类来实现继承。

如果你不想把视野局限于jQuery的话，那就多关注一下Prototype（http://prototypejs.org/）,它包含很多不错的API，并且是其他很多类库的灵感来源。

jQuery的作者John Resig在他的blog中写过一篇文章，专门讲解如何实现经典的类继承（http://goo.gl/09l0V）,这篇文章也值得一读，尤其是当你想挖掘JavaScript原型系统背后的真相的时候。



