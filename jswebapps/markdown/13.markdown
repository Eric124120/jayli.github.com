# 第13章 JavaScriptMVC类库

Justin Meyer（http://jupiterjs.com/pages/justin-meyer），JavaScriptMVC的作者，贡献了本章内容。

JavaScriptMVC（JMVC）是一个基于JQuery的JavaScript框架。它基本上就是一个全面的前端开发框架，将一些实用的测试工具、依赖关系管理、文档和一个非常有用的jQuery插件的网站都打包在了一起了。

同时，JavaScriptMVC的每一个单独的部分都可以独立使用，而不依赖于其他部分，这使得该类库非常轻量。它的类、模型、视图和控制器连接在一起通过缩减和压缩只有7k大小，并且各部分独立使用就更小了。JavaScriptMVC的独立性能让应用开始时很小，遇到Web上非常复杂的应用程序时也能扩展来从容应对。

本章内容覆盖JavaScriptMVC的$.Class、$.Model、$.View和$.Controller。下面依次来介绍这些组件：

$.Class

基于JavaScript的类系统

$.Model

传统的模型层

$.View

客户端模板系统

$.Controller

jQuery的widget工厂
	
JavaScriptMVC的命名习惯和传统的模型-视图-控制器（http://goo.gl/488Hp）设计模式有轻微的不同。例如，$.Controller用来创建传统的视图控制器，就像分页按钮和列表，而传统的控制器在传统的视图和模型之间进行协同的。

## 设置

JavaScriptMVC可以作为单个下载来使用，包含了整个框架的所有内容。既然本章内容只涉及到MVC部分，请使用编译下载工具（http://javascriptmvc.com/builder.html）；选中控制器、模型和视图的EJS模板；然后点击下载。

下载中包含了正常和缩减的两个版本，连同jQuery和你选中的插件一起。在页面中加载以下脚本标签：

	<script type='text/javascript' src='jquery-1.6.1.js'></script>  
	<script type='text/javascript' src='jquerymx-1.0.custom.js'></script>
	
##Class

JMVC的控制权和模型继承自它的帮助类：$.Class。创建一个类，可以调用$.Class(NAME, [classProperties, ] instanceProperties])：

	$.Class("Animal",{
	  breathe : function(){
		 console.log('breathe'); 
	  }
	});
	
在上面的例子中，Animal的实例有一个breathe()方法。我们创建一个新的Animal实例就可以在其之上调用breathe()方法：

	var man = new Animal();
	man.breathe();

如果想创建个子类，只要简单的调用基类构造函数，传递子类名和属性即可：

	Animal("Dog",{
	  wag : function(){
		console.log('wag');
	  }
	})
	var dog = new Dog;
	dog.wag();
	dog.breathe();
	
### 实例化

当创建一个类新的实例时，会调用类的init方法，并将参数传递给构造函数：

	$.Class('Person',{
	  init : function(name){
		this.name = name;
	  },
	  speak : function(){
		return "I am " + this.name + ".";
	  }
	});
	var payal = new Person("Payal");
	assertEqual( payal.speak() ,  'I am Payal.' );
	
### 调用基类的方法

使用`this._super`来调用基类的方法。下面的代码比person提供更有“品味”的问候语：

	Person("ClassyPerson", {
	  speak : function(){
		return "Salutations, " + this._super();
	  }
	});
	var fancypants = new ClassyPerson("Mr. Fancy");
	assertEquals( fancypants.speak() , 'Salutations, I am Mr. Fancy.')

### 代理

Class的callback方法返回一个函数，在里面“this”指向了适当的上下文，类似jQuery的$.proxy（http://api.jquery.com/jQuery.proxy/）。下面的代码创建了一个Clicky类，来统计它被点击了多少次：

	$.Class("Clicky",{
	  init : function(){
		this.clickCount = 0;
	  },
	  clicked: function(){
		this.clickCount++;
	  },
	  listen: function(el){
		el.click( this.callback('clicked') );
	  }
	})
	var clicky = new Clicky();
	clicky.listen( $('#foo') );
	clicky.listen( $('#bar') ) ;

### 静态继承

Class能够定义静态属性和方法的继承。下面的代码允许调用Person.findOne(ID, success(person))从服务器获取一个person实例。成功后调用回调函数，传递进Person的一个实例对象，它拥有speak方法：

	$.Class("Person",{
	  findOne : function(id, success){
		$.get('/person/'+id, function(attrs){
		  success( new Person( attrs ) );
		},'json')
	  }
	},{
	  init : function(attrs){
		$.extend(this, attrs)
	  },
	  speak : function(){
		return "I am "+this.name+".";
	  }
	})
	Person.findOne(5, function(person){
	  assertEqual( person.speak(), "I am Payal." );
	})

### 自省

Class提供命名空间以及访问类名和命名空间名的对象：

	$.Class("Jupiter.Person");
	Jupiter.Person.shortName; //-> 'Person'
	Jupiter.Person.fullName;  //-> 'Jupiter.Person'
	Jupiter.Person.namespace; //-> Jupiter
	var person = new Jupiter.Person();
	person.Class.shortName; //-> 'Person'
	
### 一个模型的例子

全部综合起来，我们可以开发一个最基本的ORM风格的模型层。只要继承自Model，从REST形式的Web服务器请求数据，得到数据后包装在继承自Model的实例中：

	$.Class("Model",{
	  findOne : function(id, success){
		$.get('/' + this.fullName.toLowerCase() + '/' + id, 
		  this.callback(function(attrs){
			 success( new this( attrs ) );
		  })
		},'json')
	  }
	},{
	  init : function(attrs){
		$.extend(this, attrs)
	  }
	})
	Model("Person",{
	  speak : function(){
		return "I am "+this.name+".";
	  }
	});
	Person.findOne(5, function(person){
	  alert( person.speak() );
	});
	Model("Task");
	Task.findOne(7,function(task){
	  alert(task.name);
	});
	
这类似于JavaScriptMVC的模型层的工作原理。

## 模型

JavaScriptMVC的模型和它相关的插件提供了很多组织模型数据的工具，如校验、关联、列表等等更多。但核心功能集中在服务封装、类型转换和事件上。

### 属性和可观察

对一个模型层来说最重要就是获取和设置模型上数据属性的能力，以及一个模型实例上监听各种变化。这就是观察者模式，它处于MVC应用的中心地带——视图监听模型中的变化。

所幸的是用了JavaScriptMVC就很容易让所有的数据可观察。分页是一个很好的例子。在页面上存在多个分页控件是很常见的。例如，一个用来控制Next和Previous按钮；另一个用来控制当前正在显示的详情（例如，“Showing items 1-20”）。所有分页控件都需要这些数据：

offset

显示的第一项的索引值

limit

显示选项的数量

count

选项的总数量
	
可以这样用JavaScriptMVC的$.Model来组织模型：

	var paginate = new $.Model({
	  offset: 0,
	  limit: 20,
	  count: 200
	});
	
paginate变量现在就变成了可观察的。可以将其传递给分页控件来读取、写入以及监听它的属性的变化。你可以用常规的方法或使用model.attr(NAME)方法来读取属性：

	assertEqual( paginate.offset, 0 );
	assertEqual( paginate.attr('limit') , 20 );
	
如果点击了Next按钮，我们需要将offset加1，可以使用model.attr(NAME, VALUE)。如下代码将offset移动到下一页：

	paginate.attr('offset', 20);

当一个控件改变了paginate的状态，其他的控件应该接收到通知。你可以用model.bind(ATTR, success( ev, newVal))来绑定一个特定属性的变化，并更新该控件：

	paginate.bind('offset', function(ev, newVal){
	  $('#details').text( 'Showing items ' + (newVal + 1 ) + '-' + this.count )
	})
	
只要绑定“updated.attr”事件，就可以监听任何属性的变化：

	paginate.bind('updated.attr', function(ev, newVal){
	  $('#details').text( 'Showing items ' + (newVal+1 )+ '-' + this.count )
	})

下面的代码是一个next-previous的jQuery插件，它接受paginate的数据：

	$.fn.nextPrev = function(paginate){
	   this.delegate('.next','click', function(){
		 var nextOffset = paginate.offset + paginate.limit;
		 if( nextOffset < paginate.count){
		   paginate.attr('offset', nextOffset );
		 }
	   });
	   this.delegate('.prev','click', function(){
		 var nextOffset = paginate.offset-paginate.limit;
		 if( 0 < paginate.offset ){
		   paginate.attr('offset', Math.max(0, nextOffset) );
		 }
	   });
	   var self = this;
	   paginate.bind('updated.attr', function(){
		 var next = self.find('.next'),
			 prev = self.find('.prev');
		 if( this.offset == 0 ){
		   prev.removeClass('enabled');
		 } else { 
		   prev.removeClass('disabled');
		 }
		 if( this.offset > this.count - this.limit ){
		   next.removeClass('enabled');
		 } else { 
		   next.removeClass('disabled');
		 }
	   });
	};
	
这个插件还有一些小问题。首先，如果控件从页面上删除了，它不会从paginate上解除绑定。我们在讨论控制器时来解决这个问题。

其次，逻辑上插件内部应该防止出现负的offset或offset超出总数的现象。这个逻辑应该在模型中处理。为了修复这个问题，我们需要创建一个分页类，在那里可以添加额外的约束来限制limit、offset和count的值。

### 扩展模型

JavaScriptMVC的模型继承自$.Class。因此，你创建的模型类是从$.Model(NAME, [STATIC, ], PROTOTYPE)上继承的：

	$.Model('Paginate',{
	  staticProperty: 'foo'
	},{
	  prototypeProperty: 'bar'
	})

还有一些方法来让Paginate模型更加有用。下面要讨论的是，通过添加setter方法，就可以限制设置count和offset的值。

### Setters

setter方法是模型的原型方法，它们的命名规则如setName。当存在val，并传递给model.attr(NAME, val)时，它们就会被调用。同时，还传递sucess和error等回调函数。通常，该方法应该返回模型实例被设置的值，或者调用error函数输出一个错误消息。sucess函数是在异步调用setter时使用的。

Paginate模型用setter来防止被设置成无效的总数和偏移量。例如，必须保证数值不能为负数：

	$.Model('Paginate',{
	  setCount : function(newCount, success, error){
		return newCount < 0 ? 0 : newCount;
	  },
	  setOffset : function(newOffset, success, error){
		return newOffset < 0 ? 0 : 
	Math.min(newOffset, !isNaN(this.count - 1) ? this.count : Infinity )
	  }
	});

现在，该nextPrev插件能够比较随意地设置偏移量：

	this.delegate('.next','click', function(){
	  paginate.attr('offset', paginate.offset+paginate.limit);
	});
	this.delegate('.prev','click', function(){
		paginate.attr('offset', paginate.offset-paginate.limit );
	});
	
### Defaults

设置Paginate实例的静态属性defaults来赋予它初始的默认值。在新建一个paginate实例时，如果没有提供初始值就会使用这些默认值：

	$.Model('Paginate',{
	  defaults : {
		count: Infinity,
		offset: 0,
		limit: 100
	  }
	},{
	  setCount : function(newCount, success, error){ ... },
	  setOffset : function(newOffset, success, error){ ... }
	});
	var paginate = new Paginate({count: 500});
	assertEqual(paginate.limit, 100);
	assertEqual(paginate.count, 500);
	
给Paginate模型添加辅助方法，可以把下一步和上一步变得更加简单。

### 辅助方法

有一些原型方法来协助设置或获取模型实例上有用的数据。下面的代码是一个完成的Paginate模型，包含了next和prev等方法，用来页面前进和回退。同时提供了canNext和canPrev方法来判断页面是否能够移动到下一步：

	$.Model('Paginate',{
	  defaults : {
		count: Infinity,
		offset: 0,
		limit: 100
	  }
	},{
	  setCount : function( newCount ){
		return Math.max(0, newCount  );
	  },
	  setOffset : function( newOffset ){
		return Math.max( 0 , Math.min(newOffset, this.count ) )
	  },
	  next : function(){
		this.attr('offset', this.offset+this.limit);
	  },
	  prev : function(){
		this.attr('offset', this.offset - this.limit )
	  },
	  canNext : function(){
		return this.offset > this.count - this.limit
	  },
	  canPrev : function(){
		return this.offset > 0
	  }
	})
	
因此，我们的jQuery widget越来越精致了：

	$.fn.nextPrev = function(paginate){
	   this.delegate('.next','click', function(){
		 paginate.attr('offset', paginate.offset+paginate.limit);
	   })
	   this.delegate('.prev','click', function(){
		 paginate.attr('offset', paginate.offset-paginate.limit );
	   });
	   var self = this;
	   paginate.bind('updated.attr', function(){
		 self.find('.prev')[paginate.canPrev() ? 'addClass' : 'removeClass']('enabled')
		 self.find('.next')[paginate.canNext() ? 'addClass' : 'removeClass']('enabled');
	   })
	};

### 服务封装

刚刚我们看到了$.Model在客户端状态建模方面是多么的有用。但是，对多数应用来说，重要的数据都放在服务器而非客户端上。客户端需要在服务器上创建、获取、更新和删除（CRUD）数据。维护好客户端和服务器上数据的一致性是一件相当不容易的事情；而$.Model简化该问题。

$.Model非常灵活。它可以与任何类型的服务和数据类型协同工作。本书只覆盖$.Model与当下最常用和流行的服务和数据类型工作原理：表述性状态转移（REST）和JSON。

REST服务使用URL和HTTP的谓词POST、GET、PUT和DELETE来分别创建、获取、更新和删除数据。例如，一个task服务看上去会是这个样子：

	create   → POST   /tasks
	read all → GET    /tasks
	read     → GET    /tasks/2
	update   → PUT    /tasks/2
	delete   → DELETE /tasks/2
	
使用下面的代码就能在服务器上完成数据的创建、获取、更新和删除：

	$.Model("Task",{
	  create  : "POST /tasks.json",
	  findOne : "GET /tasks/{id}.json",
	  findAll : "GET /tasks.json",
	  update  : "PUT /tasks/{id}.json",
	  destroy : "DELETE /tasks/{id}.json"
	},{ });
	
接下来进一步说明怎么来用Task模型完成CRUD的操作。

#### 创建任务

	new Task({ name: 'do the dishes'}).save( 
	  success( task, data ), 
	  error( jqXHR) 
	) //=> taskDeferred
	
为了在服务器上创建一个模型的实例，首先使用Model(attributes)创建一个实例，然后调用save()。它会检查是否已经有ID了，这个例子中是没有的，所以save()发起了一个create请求并传递该task的一些属性。它接受两个参数：

sucess

当请求成功后被回调的函数。调用时会传入task实例和服务器返回的数据data。

error

当请求发生错误时被回调的函数。调用时会传入jQuery包装过的XHR对象。
	
sava()返回一个封装了被创建task对象的延时对象。

#### 获取任务

	Task.findOne(params, 
	  success( task ), 
	  error( jqXHR) 
	) //=> taskDeferred

从服务器获取一个task需要三个参数：

params

传递给服务器的数据；通常是一个ID，如{id: 2}。

success

当请求成功后被回调的函数。调用时会传入task实例。

error

当请求发生错误时被回调的函数。
	
findOne()返回一个封装了task对象的延时对象。
	
#### 获取多个任务

	Task.findAll(params, 
	  success( tasks ), 
	  error( jqXHR) 
	) //=> tasksDeferred

从服务器获取一个包含多个task的数组也需要3个参数：

params

传递给服务器的数据；通常是一个空对象（{}）或过滤器{limit: 20, offset: 100}。

success

当请求成功后被回调的函数。调用时会传入包含多个task实例的数组。

error

当请求发生错误时被回调的函数。

findAll()返回一个封装了一个包含多个task对象的数组的延时对象。
	
#### 更新任务

	task.attr('name','take out recycling');
	task.save( 
	  success( task, data ), 
	  error( jqXHR) 
	) //=> taskDeferred
	
为了更新服务器数据，首先需要使用模型实例的attr来改变属性，然后调用save()。save()的参数和返回值都与上面创建时一样。

#### 销毁任务

	task.destroy( 
	  success( task, data ), 
	  error( jqXHR) 
	) //=> taskDeferred
	
从服务器上删除一个task需要2个参数：

success

当请求成功后被回调的函数。调用时传入该task实例和服务器返回的数据data。

error

当请求发生错误时被回调的函数。
	
类似save()，destroy()的返回值是一个封装了被销毁的task对象的延时对象。Task模型基本上已经能为我们提供合格的服务了。

### 类型转换

你是否发现了服务器响应的createdAt的值，如1303173531164这样的数字，我们应该如何处理？这个数字实际上代表了20011年4月18日。相对于从task.createdAt中直接得到这个数字，如果能返回一个JavaScript日期对象如new Date(1303173531164)这样将会更加有用。要不然我们可能会用一个setCreatedAt setter来做这些事情，但如果有很多日期类型需要转换，很快这将是重复的工作。

为了让这些变得更简单，$.Model可以定义一个属性的类型，以及一个这些类型的转换函数。在静态的attributes对象上设置属性的类型，在静态的convert对象上设置转换方法：

	$.Model('Task',{
	  attributes : {
		createdAt : 'date'
	  },
	  convert : {
		date : function(date){
		  return typeof date == 'number' ? new Date(date) : date;
		}
	  }
	},{});

现在Task将createdAt转换成Date类型的数据。如果要枚举每个task对象的年份，代码如下：

	Task.findAll({}, function(tasks){
	  $.each(tasks, function(){
		console.log( "Year = "+this.createdAt.fullYear() )
	  })
	});
	
### CRUD事件

当模型的实例在被创建、更新或销毁时它将发布（触发）一些事件。你既可以在全局监听这些事件也可以在单个的模型实例上监听。监听创建、更新或销毁事件可以使用MODEL.bind(EVENT, callback（ev, instance）)。

当一个task被创建时我们想知道，因为之后我们才能将它添加到页面上。在添加以后，我们会监听该task的所有更新以便能正确地显示其名字。看看下面是如何实现的：

	Task.bind('created', function(ev, task){
	  var el = $('<li>').html(todo.name);
	  el.appendTo($('#todos'));
	  task.bind('updated', function(){
		el.html(this.name);
	  }).bind('destroyed', function(){
		el.remove();
	  })
	});
	
## 视图中使用客户端模板

JavaScriptMVC的视图实质上就是客户端模板，它接受数据然后返回一个字符串。通常情况，就是将要被插到DOM中的HTML字符串。

$.View是一个模板接口，它使用模板来降低复杂度，功能如下：

- 方便、一致的语法
- 从HTML元素或外部文件中加载模板
- 同步或异步方式加载模板
- 模板预加载
- 缓存已处理的模板
- 产品构建时批量处理模板
- $.Deferred（延时对象）的支持

JavaScriptMVC打包了4中不同的模板引擎：

- EJS
- JAML
- Micro
- Tmpl

下面的例子用了EJS模板，但技术上各个模板引擎是通用的（只有一些小的语法不同）。

### 基本用法

在使用视图时，你总是会将模板渲染的结果插到页面中。jQuery.View覆盖了jQuery的修改器，使用起来如此方便：

	$("#foo").html('mytemplate.ejs',{message: 'hello world'})
	
代码流程：

1. 加载文件mytemplate.ejs中的模板。看起来如下：

	<h2><%= message %></h2>

2. 应用{message: ‘hello world'}来渲染，结果如下：

	<h2>hello world</h2>

3. 插到元素foo中以后，看起来如下：

	<div id='foo'><h2>hello world</h2></div>
	
### jQuery修改器

以下jQuery修改器方法可以和模板一起协同使用：

	$('#bar').after('temp.ejs',{});
	$('#bar').append('temp.ejs',{});
	$('#bar').before('temp.ejs',{});
	$('#bar').html('temp.ejs',{});
	$('#bar').prepend('temp.ejs',{});
	$('#bar').replaceWith('temp.ejs',{});
	$('#bar').text('temp.ejs',{});

### 用Script标签加载

视图可以从script便签或文件中加载。要从一个script标签加载，首先创建一个script标签，并设置其type属性为模板的属性（text/ejs），用一个id来标识该模板：

	<script type='text/ejs' id='recipesEJS'>
	<% for(var i=0; i < recipes.length; i++){ %>
	  <li><%=recipes[i].name %></li>
	<%} %>
	</script>
	
用该模板来渲染，例如：

	$("#foo").html('recipesEJS', recipeData)
	
请注意，我们传递了想要渲染元素的id。

### $.View和子模板

有时我们只需要渲染的字符串，这种情况下，可以直接使用$.View(TEMPLATE, data)。给$.View传递模板的路径和数据：

	var html = $.View("template/items.ejs", items );

其实，最常见的案例是子模板。通常将单个项目模板和项目列表模板（items.ejs）隔离开比较实际。如，用template/items.ejs为每个项目的渲染一个<>，但用template/item.ejs渲染每个项目内部的内容：

<% for( var i = 0; i < this.length; i++){ %>
  <li>
    <%= $.View("template/item.ejs", this[i]);  
  </li>
< % } %>

this指代的是传递给模板的数据。这个案例中template/items.ejs，this是包含多个项目的数组。在template/item.ejs是单个项目。

### 延时对象

当前使用Ajax请求数据并用模板来渲染结果是非常普遍的现象。如前面$.Model小节中提到的Task模型，可以想下面这样来渲染#tasks：

	Task.findAll({}, function(tasks){
	  $('#tasks').html("views/tasks.ejs" , tasks )
	})
	
$.View支持延时（http://api.jquery.com/category/deferred-object/），允许强大、简洁、高性能的语法。如果在传递给$.View的渲染数据中或jQuery的修改器中能找到一个延时对象，$.View将异步加载模板，并等待所有延时结束，模板加载完成以后才开始渲染。

模型方法findAll、findOne、save和destroy等都是返回延时对象。这就允许用一行代码来重写task列表的渲染：

	$('#tasks').html("views/tasks.ejs" , Task.findAll() )

有多个延时对象也工作得很好：

	$('#app').html("views/app.ejs" , {
	  tasks: Task.findAll(),
	  users: User.findAll()
	})

### 打包、预加载和性能

默认情况下，$.View是同步加载模板的，这样做是因为它认为你：

- 把模板放置在script标签之内
- 模板和JavaScript代码打包编译在一起
- 预加载模板

JavaScriptMVC不推荐奖模板放在script标签之内的。script标签模板在不同的JavaScript应用之间很难复用。同时，它降低了加载的性能，因为你的app不是立即就需要这些模板的。

JavaScriptMVC推荐初始化打包时使用应用JavaScript的模板，然后预加载后续要用到的模板。

SetalJS、JavaScriptMVC的编译系统可以处理和打包模板，并将其添加到一个缩减后的生产环境编译包里面。使用非常简单steal.views(PATH, ...)，这样来指定模板：
	
	steal.views('tasks.ejs','task.ejs');
	
接下来，当$.View查找该模板时，它就使用这份缓存却节省了额外的Ajax请求。

对于不是立即需要使用的模板，可以使用jQuery.get来预加载并换成起来。很简单，只要提供模板的URL，一个dataType叫做“view”（在页面加载完成一小段时间以后比较好）：

	$(window).load(function(){
	  setTimeout(function(){
		$.get('users.ejs',function(){},'view');
		$.get('user.ejs',function(){},'view');
	  },500)
	})

## $.Controller：jQuery插件工厂

JavaScriptMVC的控制器包含了很多东西。这里有一个jQuery插件工厂。可以作为传统的视图使用，创建分页widgets和栅格化控件。也可以作为传统的控制器使用，初始化控件并绑定到模型上。大多数情况下，控制器是一种组织应用程序代码非常棒的方法。

控制器提供了一些非常易用的特性，如：

- 创建jQuery插件
- 自动绑定
- 默认选项值
- 自动判定

但是控制器最重要的特性并不是很明显。下面的代码用于创建一个类似tooltip的widget，它会一直显示，在文档被点击时关闭：

	$.fn.tooltip = function(){
	  var el = this[0];
	  $(document).click(function(ev){
		if (ev.target !== el)
		  $(el).remove();
	  });
	  $(el).show();
	  return this;
	});

如何使用呢？直接将该元素添加到要显示的页面上，然后调用tooltip：

	$("<div class='tooltip'>Some Info</div>")
		.appendTo(document.body)
		.tooltip()

但上述代码是有问题的。你能指出问题的所在吗？提示一下：如果你的页面生命周期很长，有很多这样的tooltip被创建出来时会是怎么样呢？

问题就在于内存泄漏！每个tooltip元素及其子元素，都会永远保留在内存中。这是因为click事件处理句柄并没有从document中移除，它形成的闭包仍然在引用着字该元素。

这是一个非常容易犯下的错误。jQuery对从页面上移除的元素本来会自动解除所有事件处理句柄的绑定，从而开发者一般不需要关心解绑的问题。但在该案例中，我们是在该widget的外面——document中——所以并没有解除事件的绑定。

但在模型-视图-控制的结构下，控制器监听视图，然后视图监听模型。经常是在widget的外面来监听元素。例如，在$.Model小节中介绍的nextPrev这个widget，是在paginate模型中监听更新的：

	paginate.bind('updated.attr', function(){
	  self.find('.prev')[this.canPrev() ? 'addClass' : 'removeClass']('enabled')
	  self.find('.next')[this.canNext() ? 'addClass' : 'removeClass']('enabled');
	})
	
但并没有从paginate中解绑事件！忘记移除事件处理句柄是一个潜在的错误的根源。尽管如此，tooltip和nextPrev都没有导致错误，只不过它们在安静地吞噬应用程序的性能。所幸的是，$.Controller让事情更简单、更有组织。tooltip的代码可以这样写：

	$.Controller('Tooltip',{
	  init: function(){
		this.element.show()
	  },
	  "{document} click": function(el, ev){
		if(ev.target !== this.element[0]){
		  this.element.remove()
		}
	  }
	})
	
当点击文档时，该元素从DOM中移除，$.Controller将自动解绑document的click事件处理句柄。

$.Controller对nextPrev也做了同样的事情，绑定到Paginate模型：

	$.Controller('Nextprev',{
	  ".next click" : function(){
		var paginate = this.options.paginate;
		paginate.attr('offset', paginate.offset+paginate.limit);
	  },
	  ".prev click" : function(){
		var paginate = this.options.paginate;
		paginate.attr('offset', paginate.offset-paginate.limit );
	  },
	  "{paginate} updated.attr" : function(ev, paginate){
		this.find('.prev')[paginate.canPrev() ? 'addClass' : 'removeClass']('enabled')
		this.find('.next')[paginate.canNext() ? 'addClass' : 'removeClass']('enabled');
	  }
	})
	// 创建一个nextprev控制器
	$('#pagebuttons').nextprev({ paginate: new Paginate() })
	
如果元素#pagebuttons从页面上移除了，NextPrev控制器实例将自动将其从Paginate模型上解除绑定。

到目前为止对于error-free的代码，你的胃口刚好被适当地刺激了一下。接下来就详细地介绍$.Controller的工作原理。

### 概览

$.Controller继承自$.Class。为了创建一个控制器类，调用$.Conroller(NAME, classProperties, instanceProperties)函数，传入控制器的名字，静态方法和实例方法即可。如下的代码开始创建一个可复用的列表widget：
	
	$.Controller("List", {
	  defaults : {}
	},{
	  init : function(){  },
	  "li click" : function(){  }
	})
	
创建一个控制器类以后，它还用类似的名字创建了一个jQuery辅助方法。该辅助方法主要用于在页面的元素之上创建新的控制器实例。方法名就是控制器名字的下划线形式，每段都用下划线替换。例如，$.Controller('App.Foo.Bar')的辅助函数就是$(el).app_foo_bar()。

### 控制器实例化

为了创建一个控制器实例，调用new Controller(element, options)，传入一个HTML元素或者由jQuery包装的元素，另一个可选的对象来配置控制器。例如：

	new List($('ul#tasks'), {model : Task});

也可以使用jQuery的辅助方法在#tasks元素上来创建一个List控制实例：

	$('ul#tasks').list({model : Task})
	
当控制器创建以后，它将调用控制器的原型方法init，并传入：

this.element

它是用jQuery包装的HTML元素

this.options

它是传递给控制器的可选配置项与类本身的defaults对象合并以后的产物

下面的代码是改进版的List控制器，从模型请求数据，并使用可选的模板渲染到列表中：

	$.Controller("List", {
	  defaults : {
		template: "items.ejs"
	  }
	}, {
	  init : function(){
		this.element.html( this.options.template, this.options.model.findAll() ); 
	  },
	  "li click" : function(){  }
	});
	
到此为止，我们可以提供一个模板来配置List控制器。挺灵活的吧！

	$('#tasks').list({model: Task, template: "tasks.ejs"});
	$('#users').list({model: User, template: "users.ejs"})
	
如果不提供模板，List控制器会用默认的items.ejs。

### 事件绑定

在$.Controller的介绍中提到过，它最强大的特性就是事件处理句柄的绑定和解绑的能力。

当创建了一个控制器之后，它会查找动作方法。动作方法看起来像事件处理句柄——例如，“li click”。这些动作会用到jQuery.bind或jQuery.delegate。当从页面上移除和控制器关联的元素或者调用destroy时，它将会自己销毁，解除这些事件，防止内存泄漏。

下面是一些例子，动作和对应的解释：

“li click”

控制器元素内部的li之上或它内部的元素上发生点击事件

“mousemove”

控制器元素内部发生鼠标移动事件

“{window} click”

window内部的发生点击事件
	
回调动作函数的时候将传入一个用jQuery包装的元素或事件发生的对象，另一个就是事件对象。例如：

	"li click": function( el, ev ) {
	  assertEqual(el[0].nodeName, "li" )
	  assertEqual(ev.type, "click")
	}

### 模板动作

$.Controller支持模板动作。模板动作可以绑定到其他对象上，自定义事件类型或者自定义选择器。

控制器替换动作的一部分，看起来就像控制器选项中{OPTION}有一个值或者上面那个window一样。

下面是一个菜单的骨架，可以自定义针对不同的事件显示子菜单：

	$.Controller("Menu",{
	  "li {openEvent}" : function(){
		// 显示子孙
	  }
	});
	// 创建一个菜单，当点击子孙节点时显示出来
	$("#clickMenu").menu({openEvent: 'click'});
	// 创建一个菜单，当鼠标划过子孙节点时显示出来
	$("#hoverMenu").menu({openEvent: 'mouseenter'});
	
我们可以进一步增强该菜单，甚至允许自定义菜单元素的便签：

	$.Controller("Menu",{
	  defaults : {menuTag : "li"}
	},{
	  "{menuTag} {openEvent}" : function(){
		// 显示子孙
	  }
	});
	$("#divMenu").menu({menuTag : "div"})
	
模板动作让你能与元素或对象的绑定应用到控制器元素之外。例如，在$.Model小节中介绍过的Task模型会在一个新的Task创建之时产生一个“created”事件。可以让改列表widget监听tasks的创建，然后自动将它们添加到列表中：

	$.Controller("List", {
	  defaults : {
		template: "items.ejs"
	  }
	},{
	  init : function(){
		this.element.html( this.options.template, this.options.model.findAll() ); 
	  },
	  "{Task} created" : function(Task, ev, newTask){
		this.element.append(this.options.template, [newTask])
	  }
	})
	
“{Task} created”动作函数会被回调，并传入该Task模型、created事件和刚创建的Task。函数使用模板来渲染tasks的列表（这里只有一个），并将生成的HTML添加到该元素中。

但将List改进为能与任意模型协调工作就更好了。不必去硬编码实现tasks，我们让控制器以可选项的形式接受一个模型：

	$.Controller("List", {
	  defaults : {
		template: "items.ejs",
		model: null
	  }
	},{
	  init : function(){
		this.element.html( this.options.template, this.options.model.findAll() ); 
	  },
	  "{model} created" : function(Model, ev, newItem){
		this.element.append(this.options.template, [newItem])
	  }
	});
	// 创建一个任务列表
	$('#tasks').list({model: Task, template: "tasks.ejs"});
	
## 大综合：一个抽象的CRUD列表

现在我们将进一步改进该列表，使得它不仅当项目创建后能自动添加进去，而且能够自动更新并在它们销毁后能移除它们。为此，首先我们需要监听updated和destroyed事件：

	"{model} updated" : function(Model, ev, updatedItem){
	  // 找到有更改的项并更新LI
	},
	"{model} destroyed" : function(Model, ev, destroyedItem){
	  // 找到待删除的项，并将LI移除
	}

发现一个问题。我们需要以某种方式去找到表示特定模型实例的元素。为此，需要标记该元素说明它是属于该模型实例的。所幸的是，$.Model和$.View已经处理了，使得标记元素属于某个实例以及如何找到这些元素都非常简单。

在EJS视图中用某个模型实例标记元素，这是将模型实例写到元素上。tasks.ejs的代码可能如下：

	<% for(var i =0 ; i < this.length; i++){ %>
	  <% var task = this[i]; %>
	  <li <%= task %> > <%= task.name %> </li>
	<% } %>
	
tasks.ejs迭代tasks列表，对于每个task，它创建一个li元素并设置内容为task的name。但同时，它也使用了`<li><%= task %></li>`将该task添加到元素的jQuery数据中。

为了后面通过给定的模型实例得到元素，调用modelInstance.elements([CONTEXT])。它将返回jQuery包装的表示该模型实例的元素。

整合起来，列表就出来了：

	$.Controller("List", {
	  defaults : {
		template: "items.ejs",
		model: null
	  }
	},{
	  init : function(){
		this.element.html( this.options.template, this.options.model.findAll() ); 
	  },
	  "{model} created" : function(Model, ev, newItem){
		this.element.append(this.options.template, [newItem])
	  },
	  "{model} updated" : function(Model, ev, updatedItem){
		updatedItem.elements(this.element)
		  .replaceWith(this.options.template, [updatedItem])
	  },
	  "{model} destroyed" : function(Model, ev, destroyedItem){
		destroyedItem.elements(this.element)
		  .remove()
	  }
	});
	// 创建一组任务列表
	$('#tasks').list({model: Task, template: "tasks.ejs"});

使用JavaScriptMVC来创建抽象、可复用、内存安全的widgets真是简单的让人感到害怕，不是吗！

